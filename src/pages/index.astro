---
import Layout from '../layouts/Layout.astro';
---

<Layout title="Stupid Web Tricks - Amazing Web Effects & Animations">
  <!-- Hero Section -->
  <section class="relative min-h-screen flex items-center justify-center overflow-hidden">
    <!-- Animated background -->
    <div class="absolute inset-0 bg-gradient-to-br from-purple-900 via-blue-900 to-indigo-900">
      <div class="absolute inset-0 bg-[url('data:image/svg+xml,%3Csvg%20width%3D%2260%22%20height%3D%2260%22%20viewBox%3D%220%200%2060%2060%22%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%3E%3Cg%20fill%3D%22none%22%20fill-rule%3D%22evenodd%22%3E%3Cg%20fill%3D%22%239C92AC%22%20fill-opacity%3D%220.1%22%3E%3Ccircle%20cx%3D%2230%22%20cy%3D%2230%22%20r%3D%222%22/%3E%3C/g%3E%3C/g%3E%3C/svg%3E')] opacity-20"></div>
    </div>
    
    <!-- Interactive Animated Background -->
    <div class="absolute inset-0">
      <!-- Floating geometric shapes -->
      <div class="floating-shape shape-1"></div>
      <div class="floating-shape shape-2"></div>
      <div class="floating-shape shape-3"></div>
      <div class="floating-shape shape-4"></div>
      <div class="floating-shape shape-5"></div>
      <div class="floating-shape shape-6"></div>
      
      <!-- Interactive constellation particles -->
      <canvas id="particleCanvas" class="absolute inset-0 w-full h-full"></canvas>
    </div>

    <div class="relative z-10 text-center px-4 sm:px-6 lg:px-8 max-w-4xl mx-auto">
      <h1 class="text-5xl sm:text-6xl lg:text-7xl font-bold mb-6 animate-slide-up">
        <span class="gradient-text">Stupid</span>
        <br>
        <span class="text-white">Web Tricks</span>
      </h1>
      <p class="text-xl sm:text-2xl text-gray-300 mb-8 animate-slide-up" style="animation-delay: 0.2s;">
        Discover amazing web effects, animations,<br>

       and learn the techniques to create them!
      </p>
      <div class="animate-slide-up" style="animation-delay: 0.4s;">
        <a href="#categories" class="inline-flex items-center px-8 py-4 bg-gradient-to-r from-purple-600 to-blue-600 text-white font-semibold rounded-full hover:from-purple-700 hover:to-blue-700 transform hover:scale-105 transition-all duration-300 shadow-lg hover:shadow-xl">
          Explore Tricks
          <svg class="ml-2 w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
          </svg>
        </a>
      </div>
    </div>
  </section>

  <!-- Categories Section -->
  <section id="categories" class="py-20 px-4 sm:px-6 lg:px-8">
    <div class="max-w-7xl mx-auto">
      <div class="text-center mb-16">
        <h2 class="text-4xl sm:text-5xl font-bold mb-6 gradient-text">
          Choose Your Adventure
        </h2>
        <p class="text-xl text-gray-400 max-w-3xl mx-auto">
          Dive into different categories of web tricks, from simple CSS animations to complex WebGL experiments
        </p>
      </div>

      <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
        <!-- HTML Tricks Card -->
        <div class="category-card group">
          <div class="card-inner">
            <div class="card-front">
              <div class="card-icon">
                <svg class="w-12 h-12" fill="currentColor" viewBox="0 0 24 24">
                  <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                </svg>
              </div>
              <h3 class="card-title">HTML Tricks</h3>
              <p class="card-description">
                Clever HTML techniques, semantic markup tricks, and accessibility hacks
              </p>
            </div>
            <div class="card-back">
              <h3 class="text-xl font-bold mb-4">HTML Tricks</h3>
              <ul class="text-sm space-y-2">
                <li>• Semantic HTML patterns</li>
                <li>• Accessibility improvements</li>
                <li>• Form validation tricks</li>
                <li>• Meta tag optimizations</li>
              </ul>
              <a href="/html" class="mt-4 inline-block bg-white text-gray-900 px-4 py-2 rounded-full font-semibold hover:bg-gray-100 transition-colors">
                Explore →
              </a>
            </div>
          </div>
        </div>

        <!-- CSS Effects Card -->
        <div class="category-card group">
          <div class="card-inner">
            <div class="card-front">
              <div class="card-icon">
                <svg class="w-12 h-12" fill="currentColor" viewBox="0 0 24 24">
                  <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                </svg>
              </div>
              <h3 class="card-title">CSS Effects</h3>
              <p class="card-description">
                Stunning animations, transitions, and visual effects using pure CSS
              </p>
            </div>
            <div class="card-back">
              <h3 class="text-xl font-bold mb-4">CSS Effects</h3>
              <ul class="text-sm space-y-2">
                <li>• Advanced animations</li>
                <li>• Glass morphism</li>
                <li>• Gradient effects</li>
                <li>• 3D transforms</li>
              </ul>
              <a href="/css" class="mt-4 inline-block bg-white text-gray-900 px-4 py-2 rounded-full font-semibold hover:bg-gray-100 transition-colors">
                Explore →
              </a>
            </div>
          </div>
        </div>

        <!-- JavaScript Card -->
        <div class="category-card group">
          <div class="card-inner">
            <div class="card-front">
              <div class="card-icon">
                <svg class="w-12 h-12" fill="currentColor" viewBox="0 0 24 24">
                  <path d="M0 0h24v24H0V0zm22.034 18.276c-.175-1.095-.888-2.015-3.003-2.873-.736-.345-1.554-.585-1.797-1.14-.091-.33-.105-.51-.046-.705.15-.646.915-.84 1.515-.66.39.12.75.42.976.9 1.034-.676 1.034-.676 1.755-1.125-.27-.42-.404-.601-.586-.78-.63-.705-1.469-1.065-2.834-1.034l-.705.089c-.676.165-1.32.525-1.71 1.005-1.14 1.291-.811 3.541.569 4.471 1.365 1.02 3.361 1.244 3.616 2.205.24 1.17-.87 1.545-1.966 1.41-.811-.18-1.26-.586-1.755-1.336l-1.83 1.051c.21.48.45.689.81 1.109 1.74 1.756 6.09 1.666 6.871-1.004.029-.09.24-.705.074-1.65l.046.067zm-8.983-7.245h-2.248c0 1.938-.009 3.864-.009 5.805 0 1.232.063 2.363-.138 2.711-.33.689-1.18.601-1.566.48-.396-.196-.597-.804-.83-1.43l-.003-.032h-2.419v-.814c.63-.893 1.233-1.805 1.817-2.728 1.061-1.645 2.268-3.287 3.35-4.844h2.008v5.797h.005z"/>
                </svg>
              </div>
              <h3 class="card-title">JavaScript</h3>
              <p class="card-description">
                Interactive features, DOM manipulation, and modern JavaScript techniques
              </p>
            </div>
            <div class="card-back">
              <h3 class="text-xl font-bold mb-4">JavaScript</h3>
              <ul class="text-sm space-y-2">
                <li>• DOM manipulation</li>
                <li>• Event handling</li>
                <li>• Async patterns</li>
                <li>• Performance tricks</li>
              </ul>
              <a href="/javascript" class="mt-4 inline-block bg-white text-gray-900 px-4 py-2 rounded-full font-semibold hover:bg-gray-100 transition-colors">
                Explore →
              </a>
            </div>
          </div>
        </div>

        <!-- SVG & Canvas Card -->
        <div class="category-card group">
          <div class="card-inner">
            <div class="card-front">
              <div class="card-icon">
                <svg class="w-12 h-12" fill="currentColor" viewBox="0 0 24 24">
                  <path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
                </svg>
              </div>
              <h3 class="card-title">SVG & Canvas</h3>
              <p class="card-description">
                Vector graphics, canvas animations, and creative visual effects
              </p>
            </div>
            <div class="card-back">
              <h3 class="text-xl font-bold mb-4">SVG & Canvas</h3>
              <ul class="text-sm space-y-2">
                <li>• SVG animations</li>
                <li>• Canvas drawings</li>
                <li>• Interactive graphics</li>
                <li>• Data visualizations</li>
              </ul>
              <a href="/svg-canvas" class="mt-4 inline-block bg-white text-gray-900 px-4 py-2 rounded-full font-semibold hover:bg-gray-100 transition-colors">
                Explore →
              </a>
            </div>
          </div>
        </div>

        <!-- WebGL Card -->
        <div class="category-card group">
          <div class="card-inner">
            <div class="card-front">
              <div class="card-icon">
                <svg class="w-12 h-12" fill="currentColor" viewBox="0 0 24 24">
                  <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                </svg>
              </div>
              <h3 class="card-title">WebGL</h3>
              <p class="card-description">
                Advanced 3D graphics, shaders, and immersive web experiences
              </p>
            </div>
            <div class="card-back">
              <h3 class="text-xl font-bold mb-4">WebGL</h3>
              <ul class="text-sm space-y-2">
                <li>• 3D graphics</li>
                <li>• Shader programming</li>
                <li>• Interactive 3D</li>
                <li>• Performance optimization</li>
              </ul>
              <a href="/webgl" class="mt-4 inline-block bg-white text-gray-900 px-4 py-2 rounded-full font-semibold hover:bg-gray-100 transition-colors">
                Explore →
              </a>
            </div>
          </div>
        </div>

        <!-- Coming Soon Card -->
        <div class="category-card group opacity-75">
          <div class="card-inner">
            <div class="card-front">
              <div class="card-icon">
                <svg class="w-12 h-12" fill="currentColor" viewBox="0 0 24 24">
                  <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
                </svg>
              </div>
              <h3 class="card-title">More Coming</h3>
              <p class="card-description">
                Additional categories and tricks are being added regularly
              </p>
            </div>
            <div class="card-back">
              <h3 class="text-xl font-bold mb-4">Stay Tuned</h3>
              <p class="text-sm">
                We're constantly adding new tricks and categories. Follow us on GitHub for updates!
              </p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </section>

  <!-- Features Section -->
  <section class="py-20 px-4 sm:px-6 lg:px-8 bg-gradient-to-r from-gray-900 to-gray-800">
    <div class="max-w-7xl mx-auto">
      <div class="text-center mb-16">
        <h2 class="text-4xl sm:text-5xl font-bold mb-6 gradient-text">
          Why Stupid Web Tricks?
        </h2>
      </div>

      <div class="grid grid-cols-1 md:grid-cols-3 gap-8">
        <div class="text-center">
          <div class="w-16 h-16 mx-auto mb-6 bg-gradient-to-r from-purple-600 to-blue-600 rounded-full flex items-center justify-center">
            <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
            </svg>
          </div>
          <h3 class="text-xl font-bold mb-4">Lightning Fast</h3>
          <p class="text-gray-400">
            Built with Astro for optimal performance and zero JavaScript by default
          </p>
        </div>

        <div class="text-center">
          <div class="w-16 h-16 mx-auto mb-6 bg-gradient-to-r from-purple-600 to-blue-600 rounded-full flex items-center justify-center">
            <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"></path>
            </svg>
          </div>
          <h3 class="text-xl font-bold mb-4">Modern Design</h3>
          <p class="text-gray-400">
            Featuring the latest UI trends, animations, and responsive design patterns
          </p>
        </div>

        <div class="text-center">
          <div class="w-16 h-16 mx-auto mb-6 bg-gradient-to-r from-purple-600 to-blue-600 rounded-full flex items-center justify-center">
            <svg class="w-8 h-8 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path>
            </svg>
          </div>
          <h3 class="text-xl font-bold mb-4">Educational</h3>
          <p class="text-gray-400">
            Learn from real examples with detailed explanations and best practices
          </p>
        </div>
      </div>
    </div>
  </section>
</Layout>

<style>
  /* Floating geometric shapes */
    .floating-shape {
      position: absolute !important;
      border-radius: 50%;
      background: linear-gradient(45deg, rgba(102, 126, 234, 0.6), rgba(118, 75, 162, 0.6));
      backdrop-filter: blur(10px);
      border: 2px solid rgba(255, 255, 255, 0.3);
      cursor: pointer;
      z-index: 20 !important;
      opacity: 0.9;
      pointer-events: auto !important;
    }

    @keyframes gentle-drift {
      0%, 100% { transform: translate(0, 0); }
      25% { transform: translate(10px, -5px); }
      50% { transform: translate(-5px, 10px); }
      75% { transform: translate(-10px, -5px); }
    }

  #particleCanvas {
    z-index: 1 !important;
    pointer-events: none !important;
  }
  
  /* Make content elements allow clicks to pass through to canvas */
  main, .hero-section, .categories-section, .features-section {
    pointer-events: auto !important;
  }
  
  /* Allow clicks to pass through text elements to canvas */
  h1, h2, h3, p, .text-5xl, .text-6xl, .text-7xl, .text-xl, .text-2xl {
    pointer-events: none !important;
  }
  
  /* Keep buttons and links clickable */
  a, button, .btn, .category-card {
    pointer-events: auto !important;
  }
  
  .shape-1 {
    width: 80px;
    height: 80px;
    top: 10%;
    left: 10%;
    animation-delay: 0s;
    background: linear-gradient(45deg, rgba(255, 0, 150, 0.6), rgba(0, 255, 255, 0.6));
  }
  
  .shape-2 {
    width: 120px;
    height: 120px;
    top: 20%;
    right: 15%;
    animation-delay: 2s;
    background: linear-gradient(45deg, rgba(255, 255, 0, 0.6), rgba(255, 0, 255, 0.6));
  }
  
  .shape-3 {
    width: 60px;
    height: 60px;
    bottom: 20%;
    left: 20%;
    animation-delay: 4s;
    background: linear-gradient(45deg, rgba(0, 255, 150, 0.6), rgba(150, 0, 255, 0.6));
  }
  
  .shape-4 {
    width: 100px;
    height: 100px;
    bottom: 30%;
    right: 25%;
    animation-delay: 1s;
    background: linear-gradient(45deg, rgba(255, 100, 0, 0.6), rgba(0, 100, 255, 0.6));
  }
  
  .shape-5 {
    width: 40px;
    height: 40px;
    top: 50%;
    left: 5%;
    animation-delay: 3s;
    background: linear-gradient(45deg, rgba(255, 255, 255, 0.6), rgba(0, 0, 0, 0.6));
  }
  
  .shape-6 {
    width: 90px;
    height: 90px;
    top: 60%;
    right: 10%;
    animation-delay: 5s;
    background: linear-gradient(45deg, rgba(150, 255, 0, 0.6), rgba(255, 0, 150, 0.6));
  }


  

  /* Category cards */
  .category-card {
    perspective: 1000px;
    height: 300px;
  }
  
  .card-inner {
    position: relative;
    width: 100%;
    height: 100%;
    text-align: center;
    transition: transform 0.6s;
    transform-style: preserve-3d;
    cursor: pointer;
  }
  
  .category-card:hover .card-inner {
    transform: rotateY(180deg);
  }
  
  .card-front, .card-back {
    position: absolute;
    width: 100%;
    height: 100%;
    backface-visibility: hidden;
    border-radius: 20px;
    padding: 2rem;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
  }
  
  .card-back {
    transform: rotateY(180deg);
    background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
  }
  
  .card-icon {
    width: 80px;
    height: 80px;
    background: linear-gradient(135deg, #667eea, #764ba2);
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 1rem;
    color: white;
  }
  
  .card-title {
    font-size: 1.5rem;
    font-weight: bold;
    margin-bottom: 1rem;
    color: white;
  }
  
  .card-description {
    color: rgba(255, 255, 255, 0.8);
    line-height: 1.6;
  }

  /* Smooth scroll behavior */
  html {
    scroll-behavior: smooth;
  }
</style>

<script>
  // Interactive Constellation Particle System
  class ConstellationSystem {
    constructor() {
      this.canvas = document.getElementById('particleCanvas');
      this.ctx = this.canvas.getContext('2d');
      this.particles = [];
      this.mouse = { x: 0, y: 0 };
      this.lastClickTime = 0;
      this.clickThrottle = 1000; // Maximum 1 click per second
      this.colorWaves = []; // Array of active color waves
      this.canClick = true; // Whether user can click (tied to wave visibility)
      this.init();
    }

    init() {
      this.resizeCanvas();
      this.createParticles();
      this.establishConnections();
      this.bindEvents();
      this.animate();
    }

    resizeCanvas() {
      this.canvas.width = window.innerWidth;
      this.canvas.height = window.innerHeight;
      
      // Recreate particles with new count based on screen size
      this.particles = [];
      this.createParticles();
      this.establishConnections();
    }

    createParticles() {
      // Adjust particle count based on screen size
      const screenArea = this.canvas.width * this.canvas.height;
      let particleCount;
      
      if (this.canvas.width <= 768) {
        // Mobile: fewer particles for better performance
        particleCount = Math.floor(screenArea / 20000);
      } else if (this.canvas.width <= 1024) {
        // Tablet: medium particle count
        particleCount = Math.floor(screenArea / 15000);
      } else {
        // Desktop: full particle count
        particleCount = Math.floor(screenArea / 12000);
      }
      
      // Ensure minimum and maximum particle counts
      particleCount = Math.max(20, Math.min(particleCount, 300));
      
      console.log(`Creating ${particleCount} particles for ${this.canvas.width}x${this.canvas.height} screen`);
      
      for (let i = 0; i < particleCount; i++) {
        const baseHue = Math.random() * 360;
        this.particles.push({
          x: Math.random() * this.canvas.width,
          y: Math.random() * this.canvas.height,
          vx: (Math.random() - 0.5) * 0.08, // Faster base velocity
          vy: (Math.random() - 0.5) * 0.08,
          baseVx: (Math.random() - 0.5) * 0.08, // Store base velocity for drift
          baseVy: (Math.random() - 0.5) * 0.08,
          size: Math.random() * 3 + 1,
          opacity: Math.random() * 0.8 + 0.2,
          baseOpacity: Math.random() * 0.8 + 0.2, // Store original opacity (same as opacity)
          hue: baseHue,
          baseHue: baseHue, // Store original hue
          baseSaturation: Math.random() * 40 + 60, // Store original saturation (60-100%)
          baseLightness: Math.random() * 30 + 40, // Store original lightness (40-70%)
          pulse: Math.random() * Math.PI * 2,
          driftPhase: Math.random() * Math.PI * 2, // For smooth drifting motion
          driftSpeed: Math.random() * 0.0005 + 0.0003, // Faster drift speed
          connections: [], // Array of connected particle indices
          currentHue: baseHue, // Start with same hue as baseHue
          waveIntensity: 0, // How much the wave affects this particle (0-1)
          waveDecay: 0 // Decay rate for wave effect
        });
      }
    }

    establishConnections() {
      // Find connections between nearby particles (increase distance for better connectivity)
      const connectionDistance = 150; // Increased to connect more clusters
      
      this.particles.forEach((particle, index) => {
        particle.connections = [];
        
        this.particles.forEach((otherParticle, otherIndex) => {
          if (index !== otherIndex) {
            const distance = Math.sqrt(
              Math.pow(particle.x - otherParticle.x, 2) + 
              Math.pow(particle.y - otherParticle.y, 2)
            );
            
            if (distance < connectionDistance) {
              particle.connections.push(otherIndex);
            }
          }
        });
      });
    }

    bindEvents() {
      window.addEventListener('resize', () => this.resizeCanvas());
      
      this.canvas.addEventListener('mousemove', (e) => {
        const rect = this.canvas.getBoundingClientRect();
        this.mouse.x = e.clientX - rect.left;
        this.mouse.y = e.clientY - rect.top;
      });
      
      this.canvas.addEventListener('mouseleave', () => {
        this.mouse.x = 0;
        this.mouse.y = 0;
      });
      
      // Add click interaction for constellation dots - works anywhere on page
      document.addEventListener('click', (e) => {
        // Throttle clicks based on wave visibility
        if (!this.canClick) {
          return; // Ignore clicks when waves are still visible
        }
        this.canClick = false; // Prevent further clicks until wave disappears
        
        // Check if click is on a button or link - if so, don't interfere
        const target = e.target;
        if (target.tagName === 'A' || target.tagName === 'BUTTON' || 
            (target.classList && target.classList.contains('category-card')) ||
            (target.parentElement && (target.parentElement.tagName === 'A' || target.parentElement.tagName === 'BUTTON'))) {
          return;
        }
        
        const rect = this.canvas.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const clickY = e.clientY - rect.top;
        
        // Only process clicks within canvas bounds
        if (clickX >= 0 && clickX <= this.canvas.width && 
            clickY >= 0 && clickY <= this.canvas.height) {
          
          // Find the closest particle to the click
          let closestParticle = null;
          let closestDistance = Infinity;
          
          this.particles.forEach(particle => {
            const distance = Math.sqrt(
              Math.pow(particle.x - clickX, 2) + 
              Math.pow(particle.y - clickY, 2)
            );
            
            if (distance < closestDistance && distance < 80) { // Increased range
              closestDistance = distance;
              closestParticle = particle;
            }
          });
          
          if (closestParticle) {
            this.createConstellationClickEffect(clickX, clickY, closestParticle);
          }
        }
      });
    }
    
    createConstellationClickEffect(clickX, clickY, particle) {
      // Create a beautiful color wave effect
      this.createColorWave(clickX, clickY, particle);
    }
    
    createColorWave(clickX, clickY, startParticle) {
      // Generate a random beautiful color for this wave
      const waveHue = Math.random() * 360;
      const waveSpeed = 2.0; // Much faster wave travel
      const waveIntensity = 1.0; // Maximum intensity
      const waveDecay = 0.01; // Slower decay - circles last exactly 1 second
      
      // Create the wave object
      const wave = {
        x: clickX,
        y: clickY,
        hue: waveHue,
        intensity: waveIntensity,
        speed: waveSpeed,
        decay: waveDecay,
        radius: 0,
        maxRadius: 300, // Maximum wave radius
        affectedParticles: new Set(), // Track which particles this wave has affected
        startTime: Date.now()
      };
      
      this.colorWaves.push(wave);
      
      // Start the wave from the clicked particle
      this.propagateWave(wave, startParticle);
    }
    
    propagateWave(wave, particle) {
      // Mark this particle as affected by this wave
      wave.affectedParticles.add(particle);
      
      // Apply wave effect to this particle - only brightness and size, keep original color
      particle.waveIntensity = wave.intensity;
      particle.waveDecay = wave.decay;
      // Don't change currentHue - keep original color
      
      // Propagate to connected particles
      particle.connections.forEach(connectionIndex => {
        const connectedParticle = this.particles[connectionIndex];
        if (connectedParticle && !wave.affectedParticles.has(connectedParticle)) {
          // Add a small delay for wave propagation effect
          setTimeout(() => {
            this.propagateWave(wave, connectedParticle);
          }, Math.random() * 30 + 20); // Much faster propagation: 20-50ms delay
        }
      });
    }
    
    updateColorWaves() {
      // Update all active color waves
      this.colorWaves = this.colorWaves.filter(wave => {
        // Update wave properties
        wave.radius += wave.speed;
        wave.intensity -= wave.decay;
        
        // Remove wave if it's faded out or reached max radius
        if (wave.intensity <= 0 || wave.radius >= wave.maxRadius) {
          // Reset affected particles - but don't instantly change colors
          wave.affectedParticles.forEach(particle => {
            particle.waveIntensity = 0;
            particle.waveDecay = 0;
            // Don't instantly reset currentHue - let it fade naturally
          });
          return false; // Remove this wave
        }
        
        return true; // Keep this wave
      });
      
      // Update particle wave effects
      this.particles.forEach(particle => {
        if (particle.waveIntensity > 0) {
          particle.waveIntensity -= particle.waveDecay;
          if (particle.waveIntensity <= 0) {
            particle.waveIntensity = 0;
            particle.waveDecay = 0;
            // Colors stay the same - no transition needed
          }
        }
      });
      
      // Allow clicking again when all waves have disappeared
      if (this.colorWaves.length === 0) {
        this.canClick = true;
      }
    }
    
    updateParticles() {
      // Update color waves
      this.updateColorWaves();
      
      // Limit total particles to prevent performance issues
      const maxParticles = 200;
      if (this.particles.length > maxParticles) {
        // Remove oldest mini-particles first
        this.particles = this.particles.filter(p => p.life === undefined).slice(0, maxParticles);
      }
      
      this.particles.forEach((particle, index) => {
        // Handle mini-particles with life spans
        if (particle.life !== undefined) {
          particle.life--;
          particle.opacity = particle.life / 60;
          
          if (particle.life <= 0) {
            this.particles.splice(index, 1);
            return;
          }
          
          // Mini-particles move faster and fade out
          particle.x += particle.vx;
          particle.y += particle.vy;
          particle.vx *= 0.98;
          particle.vy *= 0.98;
          return;
        }
        
        // Add gentle drifting motion
        particle.driftPhase += particle.driftSpeed;
        
        // Create smooth circular drift - faster movement
        const driftX = Math.cos(particle.driftPhase) * 0.0015;
        const driftY = Math.sin(particle.driftPhase) * 0.0015;
        
        // Add some randomness to the drift - faster
        const randomDriftX = (Math.random() - 0.5) * 0.0008;
        const randomDriftY = (Math.random() - 0.5) * 0.0008;
        
        // Update velocity with drift
        particle.vx += driftX + randomDriftX;
        particle.vy += driftY + randomDriftY;
        
        // Gradually return to base velocity - stronger pull back to home
        particle.vx += (particle.baseVx - particle.vx) * 0.01;
        particle.vy += (particle.baseVy - particle.vy) * 0.01;

        // Update position
        particle.x += particle.vx;
        particle.y += particle.vy;

        // Mouse interaction
        const dx = this.mouse.x - particle.x;
        const dy = this.mouse.y - particle.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < 120) {
          const force = (120 - distance) / 120;
          particle.vx += (dx / distance) * force * 0.0002;
          particle.vy += (dy / distance) * force * 0.0002;
        }

        // Apply stronger friction to prevent expansion
        particle.vx *= 0.98;
        particle.vy *= 0.98;

        // Boundary check with gentle bounce
        if (particle.x < 0 || particle.x > this.canvas.width) {
          particle.vx *= -0.8;
          particle.x = Math.max(0, Math.min(this.canvas.width, particle.x));
        }
        if (particle.y < 0 || particle.y > this.canvas.height) {
          particle.vy *= -0.8;
          particle.y = Math.max(0, Math.min(this.canvas.height, particle.y));
        }

        // Update pulse
        particle.pulse += 0.03;
        
        // Note: Brightness is now managed by timeouts, not decay
      });
    }

    drawParticles() {
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

      // Draw color wave rings
      this.colorWaves.forEach(wave => {
        if (wave.intensity > 0) {
          this.ctx.save();
          this.ctx.globalAlpha = wave.intensity * 0.8; // Much more visible
          this.ctx.strokeStyle = `hsl(${wave.hue}, 100%, 70%)`; // More saturated and brighter
          this.ctx.lineWidth = 4; // Thicker lines
          this.ctx.setLineDash([10, 5]); // More visible dashed pattern
          
          this.ctx.beginPath();
          this.ctx.arc(wave.x, wave.y, wave.radius, 0, Math.PI * 2);
          this.ctx.stroke();
          
          // Add a second, more subtle ring
          this.ctx.globalAlpha = wave.intensity * 0.3;
          this.ctx.strokeStyle = `hsl(${wave.hue}, 100%, 90%)`; // Very bright center
          this.ctx.lineWidth = 8;
          this.ctx.setLineDash([]); // Solid line for inner ring
          
          this.ctx.beginPath();
          this.ctx.arc(wave.x, wave.y, wave.radius * 0.7, 0, Math.PI * 2);
          this.ctx.stroke();
          
          this.ctx.restore();
        }
      });

      // Draw constellation connections
      this.particles.forEach((particle, index) => {
        particle.connections.forEach(connectionIndex => {
          const connectedParticle = this.particles[connectionIndex];
          if (connectedParticle) {
            // Make connections more visible when particles are affected by waves
            const waveIntensity = Math.max(particle.waveIntensity, connectedParticle.waveIntensity);
            const connectionAlpha = 0.1 + (waveIntensity * 0.6);
            const connectionWidth = 0.5 + (waveIntensity * 2.0);
            
            // Use original particle colors - no wave color changes
            let connectionColor = 'rgba(255, 255, 255, 0.1)';
            if (waveIntensity > 0) {
              // Use original particle colors, just make them brighter
              const avgHue = (particle.baseHue + connectedParticle.baseHue) / 2;
              connectionColor = `hsla(${avgHue}, 80%, 60%, ${connectionAlpha})`;
            }
            
            this.ctx.strokeStyle = connectionColor;
            this.ctx.lineWidth = connectionWidth;
            
            this.ctx.beginPath();
            this.ctx.moveTo(particle.x, particle.y);
            this.ctx.lineTo(connectedParticle.x, connectedParticle.y);
            this.ctx.stroke();
          }
        });
      });

      // Draw particles with wave effects
      this.particles.forEach(particle => {
        const pulseSize = particle.size + Math.sin(particle.pulse) * 0.5;
        
        this.ctx.save();
        
        // Increase opacity and size when affected by wave
        const waveMultiplier = 1 + (particle.waveIntensity * 1.0); // Much more dramatic size increase
        this.ctx.globalAlpha = particle.opacity * waveMultiplier;
        
        // Use original hue - particles keep their original colors
        const currentHue = particle.baseHue;
        
        // Create gradient with wave-enhanced brightness and saturation
        try {
          const gradientRadius = Math.max(pulseSize * 4 * waveMultiplier, 1); // Larger gradient
          const gradient = this.ctx.createRadialGradient(
            particle.x, particle.y, 0,
            particle.x, particle.y, gradientRadius
          );
          
          // Much more dramatic color changes when affected by wave
          if (particle.waveIntensity > 0) {
            // Wave-affected particles: bright, saturated colors
            const saturation = Math.min(particle.baseSaturation + 40, 100); // Increase saturation
            const centerLightness = Math.min(particle.baseLightness + 30, 95); // Much brighter
            const edgeLightness = Math.min(particle.baseLightness + 20, 90);
            
            gradient.addColorStop(0, `hsl(${currentHue}, ${saturation}%, ${centerLightness}%)`);
            gradient.addColorStop(1, `hsl(${currentHue}, ${saturation}%, ${edgeLightness}%)`);
          } else {
            // Normal particles: original colors
            gradient.addColorStop(0, `hsl(${currentHue}, ${particle.baseSaturation}%, ${particle.baseLightness}%)`);
            gradient.addColorStop(1, `hsl(${currentHue}, ${particle.baseSaturation}%, ${particle.baseLightness * 0.6}%)`);
          }
          
          this.ctx.fillStyle = gradient;
        } catch (error) {
          if (particle.waveIntensity > 0) {
            const saturation = Math.min(particle.baseSaturation + 40, 100);
            const lightness = Math.min(particle.baseLightness + 30, 95);
            this.ctx.fillStyle = `hsl(${currentHue}, ${saturation}%, ${lightness}%)`;
          } else {
            this.ctx.fillStyle = `hsl(${currentHue}, ${particle.baseSaturation}%, ${particle.baseLightness}%)`;
          }
        }
        
        this.ctx.beginPath();
        this.ctx.arc(particle.x, particle.y, pulseSize * waveMultiplier, 0, Math.PI * 2);
        this.ctx.fill();
        this.ctx.restore();
      });
    }

    animate() {
      try {
        this.updateParticles();
        this.drawParticles();
      } catch (error) {
        console.warn('Animation error (continuing):', error);
      }
      requestAnimationFrame(() => this.animate());
    }
  }

  // Floating Shapes Physics System
  class FloatingShapesPhysics {
    constructor() {
      this.shapes = [];
      this.isRunning = false;
      this.init();
    }

    init() {
      // Initialize existing shapes
      this.initializeShapes();
      // Start the physics loop
      this.startPhysics();
    }

    initializeShapes() {
      const existingShapes = document.querySelectorAll('.floating-shape');
      existingShapes.forEach((shape, index) => {
        const rect = shape.getBoundingClientRect();
        this.shapes.push({
          element: shape,
          x: rect.left,
          y: rect.top,
          vx: (Math.random() - 0.5) * 2, // Random velocity -1 to 1 px/frame
          vy: (Math.random() - 0.5) * 2,
          radius: rect.width / 2,
          mass: rect.width / 2 // Mass proportional to size
        });
      });
    }

    startPhysics() {
      if (this.isRunning) return;
      this.isRunning = true;
      this.physicsLoop();
    }

    physicsLoop() {
      if (!this.isRunning) return;
      
      this.updatePhysics();
      requestAnimationFrame(() => this.physicsLoop());
    }

    updatePhysics() {
      const screenWidth = window.innerWidth;
      const screenHeight = window.innerHeight;

      this.shapes.forEach((shape, index) => {
        // Update position
        shape.x += shape.vx;
        shape.y += shape.vy;

        // Screen edge collisions
        if (shape.x - shape.radius <= 0) {
          shape.x = shape.radius;
          shape.vx = Math.abs(shape.vx); // Bounce right
        }
        if (shape.x + shape.radius >= screenWidth) {
          shape.x = screenWidth - shape.radius;
          shape.vx = -Math.abs(shape.vx); // Bounce left
        }
        if (shape.y - shape.radius <= 0) {
          shape.y = shape.radius;
          shape.vy = Math.abs(shape.vy); // Bounce down
        }
        if (shape.y + shape.radius >= screenHeight) {
          shape.y = screenHeight - shape.radius;
          shape.vy = -Math.abs(shape.vy); // Bounce up
        }

        // Shape-to-shape collisions
        for (let otherIndex = index + 1; otherIndex < this.shapes.length; otherIndex++) {
          const otherShape = this.shapes[otherIndex];
          const dx = shape.x - otherShape.x;
          const dy = shape.y - otherShape.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const minDistance = shape.radius + otherShape.radius;

          if (distance < minDistance && distance > 0) {
            // Collision detected - calculate collision response
            const overlap = minDistance - distance;
            const separationX = (dx / distance) * overlap * 0.5;
            const separationY = (dy / distance) * overlap * 0.5;

            // Separate shapes
            shape.x += separationX;
            shape.y += separationY;
            otherShape.x -= separationX;
            otherShape.y -= separationY;

            // Calculate new velocities (elastic collision)
            const relativeVelocityX = shape.vx - otherShape.vx;
            const relativeVelocityY = shape.vy - otherShape.vy;
            const relativeVelocityDotProduct = relativeVelocityX * dx + relativeVelocityY * dy;
            const impulse = (2 * relativeVelocityDotProduct) / (shape.mass + otherShape.mass) / distance;

            shape.vx -= impulse * otherShape.mass * dx / distance;
            shape.vy -= impulse * otherShape.mass * dy / distance;
            otherShape.vx += impulse * shape.mass * dx / distance;
            otherShape.vy += impulse * shape.mass * dy / distance;
          }
        }

        // Apply position to DOM element
        shape.element.style.left = shape.x - shape.radius + 'px';
        shape.element.style.top = shape.y - shape.radius + 'px';
      });
    }

    addShape(element) {
      const rect = element.getBoundingClientRect();
      // Convert viewport coordinates to document coordinates
      const x = rect.left + window.scrollX + rect.width / 2;
      const y = rect.top + window.scrollY + rect.height / 2;
      
      this.shapes.push({
        element: element,
        x: x,
        y: y,
        vx: (Math.random() - 0.5) * 0.5, // Give it gentle movement immediately
        vy: (Math.random() - 0.5) * 0.5,
        radius: rect.width / 2,
        mass: rect.width / 2
      });
    }

    removeShape(element) {
      this.shapes = this.shapes.filter(shape => shape.element !== element);
    }
  }

  // Initialize everything when DOM is loaded
  document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM loaded, initializing constellation system...');

    // Initialize constellation particle system
    const constellationSystem = new ConstellationSystem();
    constellationSystem.init();
    
    // Make it globally accessible for debugging
    window.constellationSystem = constellationSystem;

    // Initialize floating shapes physics system
    const floatingShapesPhysics = new FloatingShapesPhysics();
    window.floatingShapesPhysics = floatingShapesPhysics;

    // Add interactive hover and click effects to floating shapes
    document.querySelectorAll('.floating-shape').forEach((shape, index) => {
      console.log(`Setting up shape ${index + 1}`);
      
      shape.addEventListener('mouseenter', function() {
        this.style.transform = 'scale(1.2) rotate(180deg)';
        this.style.transition = 'transform 0.3s ease';
      });
      
      shape.addEventListener('mouseleave', function() {
        this.style.transform = '';
        this.style.transition = 'transform 0.3s ease';
      });

      // Add click handler for pop animation
      shape.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation(); // Prevent click from reaching constellation system
        console.log('Shape clicked!');
        
        // Create pop animation
        this.style.transform = 'scale(2) rotate(360deg)';
        this.style.opacity = '0';
        this.style.transition = 'all 0.4s ease-out';
        
        // Create explosion effect
        createExplosionEffect(this);
        
        // Remove the clicked shape after animation
        setTimeout(() => {
          // Remove from physics system first
          floatingShapesPhysics.removeShape(this);
          this.remove();
          
          // Create a new random circle
          createNewFloatingShape();
        }, 400);
      });
    });

    // Function to create explosion effect
    function createExplosionEffect(element) {
      const rect = element.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      
      // Create explosion particles
      for (let i = 0; i < 12; i++) {
        const particle = document.createElement('div');
        particle.style.position = 'fixed';
        particle.style.left = centerX + 'px';
        particle.style.top = centerY + 'px';
        particle.style.width = '6px';
        particle.style.height = '6px';
        particle.style.borderRadius = '50%';
        particle.style.backgroundColor = `hsl(${Math.random() * 360}, 70%, 60%)`;
        particle.style.pointerEvents = 'none';
        particle.style.zIndex = '1000';
        particle.style.transform = 'translate(-50%, -50%)';
        
        document.body.appendChild(particle);
        
        // Animate particle
        const angle = (i / 12) * Math.PI * 2;
        const distance = 60 + Math.random() * 40;
        const endX = centerX + Math.cos(angle) * distance;
        const endY = centerY + Math.sin(angle) * distance;
        
        particle.animate([
          { 
            transform: 'translate(-50%, -50%) scale(1)',
            opacity: 1
          },
          { 
            transform: `translate(${endX - centerX - 3}px, ${endY - centerY - 3}px) scale(0)`,
            opacity: 0
          }
        ], {
          duration: 800,
          easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
        }).onfinish = () => {
          particle.remove();
        };
      }
    }

    // Function to create a new floating shape
    function createNewFloatingShape() {
      // Find the container that actually contains the floating shapes
      const existingShapes = document.querySelectorAll('.floating-shape');
      let container = null;
      
      if (existingShapes.length > 0) {
        container = existingShapes[0].parentElement;
      } else {
        container = document.querySelector('.absolute.inset-0');
      }
      
      if (!container) {
        console.error('Container not found');
        return;
      }
      
      const newShape = document.createElement('div');
      newShape.className = 'floating-shape';
      
      // Random properties
      const finalSize = Math.random() * 60 + 40; // 40-100px final size
      const startSize = 5; // Start very tiny
      const colors = [
        'linear-gradient(45deg, rgba(255, 0, 150, 0.6), rgba(0, 255, 255, 0.6))',
        'linear-gradient(45deg, rgba(255, 255, 0, 0.6), rgba(255, 0, 255, 0.6))',
        'linear-gradient(45deg, rgba(0, 255, 150, 0.6), rgba(150, 0, 255, 0.6))',
        'linear-gradient(45deg, rgba(255, 100, 0, 0.6), rgba(0, 100, 255, 0.6))',
        'linear-gradient(45deg, rgba(255, 255, 255, 0.6), rgba(0, 0, 0, 0.6))',
        'linear-gradient(45deg, rgba(150, 255, 0, 0.6), rgba(255, 0, 150, 0.6))',
        'linear-gradient(45deg, rgba(102, 126, 234, 0.6), rgba(118, 75, 162, 0.6))'
      ];
      
      // Random position within viewport
      const spawnX = Math.random() * (window.innerWidth - finalSize);
      const spawnY = Math.random() * (window.innerHeight - finalSize);
      
      // Apply all styles explicitly to ensure they work
      newShape.style.position = 'absolute';
      newShape.style.width = finalSize + 'px'; // Set final size immediately
      newShape.style.height = finalSize + 'px'; // Set final size immediately
      newShape.style.borderRadius = '50%';
      newShape.style.background = colors[Math.floor(Math.random() * colors.length)];
      newShape.style.top = spawnY + 'px';
      newShape.style.left = spawnX + 'px';
      newShape.style.transform = 'scale(0.1)'; // Start tiny (10% of final size)
      newShape.style.animationDelay = Math.random() * 8 + 's';
      newShape.style.cursor = 'pointer';
      newShape.style.zIndex = '20';
      newShape.style.pointerEvents = 'auto';
      newShape.style.opacity = '0.9';
      newShape.style.backdropFilter = 'blur(10px)';
      newShape.style.border = '2px solid rgba(255, 255, 255, 0.3)';
      newShape.style.transition = 'all 0.3s ease-out'; // Smooth expansion
      
      // Add event listeners
      newShape.addEventListener('mouseenter', function() {
        this.style.transform = 'scale(1.2) rotate(180deg)';
        this.style.transition = 'transform 0.3s ease';
      });
      
      newShape.addEventListener('mouseleave', function() {
        this.style.transform = '';
        this.style.transition = 'transform 0.3s ease';
      });

      newShape.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation(); // Prevent click from reaching constellation system
        
        // Create pop animation
        this.style.transform = 'scale(2) rotate(360deg)';
        this.style.opacity = '0';
        this.style.transition = 'all 0.4s ease-out';
        
        // Create explosion effect
        createExplosionEffect(this);
        
        // Remove the clicked shape after animation
        setTimeout(() => {
          // Remove from physics system first
          floatingShapesPhysics.removeShape(this);
          this.remove();
          
          // Create a new random circle
          createNewFloatingShape();
        }, 400);
      });
      
      // Insert into container
      container.appendChild(newShape);
      
      // Set final size immediately but scale from center
      newShape.style.width = finalSize + 'px';
      newShape.style.height = finalSize + 'px';
      newShape.style.transform = 'scale(0.1)'; // Start tiny (10% of final size)
      
      // Add entrance animation - expand from center using scale
      setTimeout(() => {
        newShape.style.transition = 'transform 0.3s ease-out';
        newShape.style.transform = 'scale(1)'; // Expand to full size
        
        // Add gentle CSS animation instead of physics
        setTimeout(() => {
          newShape.style.animation = 'gentle-drift 8s ease-in-out infinite';
        }, 300); // After expansion completes
      }, 50); // Small delay to ensure DOM is ready
    }

    // Animate category cards on scroll
    const observerOptions = {
      threshold: 0.1,
      rootMargin: '0px 0px -50px 0px'
    };

    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry, index) => {
        if (entry.isIntersecting) {
          setTimeout(() => {
            entry.target.style.opacity = '1';
            entry.target.style.transform = 'translateY(0)';
          }, index * 100);
        }
      });
    }, observerOptions);

    // Observe all category cards
    document.querySelectorAll('.category-card').forEach(card => {
      card.style.opacity = '0';
      card.style.transform = 'translateY(30px)';
      card.style.transition = 'opacity 0.6s ease, transform 0.6s ease';
      observer.observe(card);
    });
  });
</script>