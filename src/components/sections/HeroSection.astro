---
// HeroSection.astro - Main hero section with magnetic text, particle trail, and liquid blobs
import FloatingShapesCanvas from '../features/FloatingShapesCanvas.astro';
---

<section class="hero-section relative min-h-screen flex items-center justify-center overflow-hidden">
  <!-- Liquid blob background -->
  <div class="absolute inset-0 bg-gradient-to-br from-purple-900 via-blue-900 to-indigo-900">
    <div class="liquid-blobs absolute inset-0">
      <div class="blob blob-1"></div>
      <div class="blob blob-2"></div>
      <div class="blob blob-3"></div>
    </div>
  </div>

  <!-- Floating shapes canvas -->
  <FloatingShapesCanvas />
  
  <!-- Particle trail canvas -->
  <canvas id="particleTrail" class="absolute inset-0 w-full h-full pointer-events-none"></canvas>
  
  <!-- Content -->
  <div class="relative z-10 text-center px-4 sm:px-6 lg:px-8 max-w-4xl mx-auto content-wrapper" style="isolation: isolate;">
    <h1 class="hero-title text-5xl sm:text-6xl lg:text-7xl font-bold mb-6 animate-slide-up bangers-font" style="text-shadow: 2px 2px 4px rgba(0,0,0,0.3), 0 0 20px rgba(0,0,0,0.5); text-transform: none; letter-spacing: 3px;">
      <span class="magnetic-text" data-text="Stupid Web Tricks" style="color: #7661d1 !important; text-shadow: 2px 2px 4px rgba(0,0,0,0.5), 0 0 10px rgba(118, 97, 209, 0.3) !important;">
        <span class="word word-stupid">Stupid</span> <span class="word word-web">Web</span> <span class="word word-tricks">Tricks</span>
      </span>
    </h1>
    <p class="text-xl sm:text-2xl text-gray-300 mb-8 animate-slide-up" style="animation-delay: 0.2s;">
      Discover amazing web effects, animations,<br>
      and learn the techniques to create them!
    </p>
    <div class="animate-slide-up" style="animation-delay: 0.4s;">
      <a href="#categories" class="hero-button inline-flex items-center px-8 py-4 bg-gradient-to-r from-purple-600 to-blue-600 text-white font-semibold rounded-full hover:from-purple-700 hover:to-blue-700 transform hover:scale-105 transition-all duration-300 shadow-lg hover:shadow-xl cursor-pointer relative z-50">
        Explore Tricks
        <svg class="ml-2 w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
        </svg>
      </a>
    </div>
  </div>
</section>

<script>
  // Magnetic Text Effect
  class MagneticText {
    private elements: HTMLElement[] = [];
    private mouseX = 0;
    private mouseY = 0;
    private isActive = false;
    private lastMouseMoveTime = 0;
    private idleTimeout: number | null = null;
    private isGlowing = false;
    private animationFrame: number | null = null;
    private mouseMoveHandler: (e: MouseEvent) => void;
    private mouseLeaveHandler: () => void;

    constructor() {
      this.mouseMoveHandler = (e: MouseEvent) => this.handleMouseMove(e);
      this.mouseLeaveHandler = () => this.handleMouseLeave();
    }

    init() {
      this.elements = Array.from(document.querySelectorAll<HTMLElement>('.magnetic-text'));
      if (this.elements.length === 0) return;

      const heroSection = document.querySelector('.hero-section');
      if (!heroSection) return;

      heroSection.addEventListener('mousemove', this.mouseMoveHandler);
      heroSection.addEventListener('mouseleave', this.mouseLeaveHandler);
      this.animate();
    }

    handleMouseMove(e: MouseEvent) {
      this.mouseX = e.clientX;
      this.mouseY = e.clientY;
      this.isActive = true;
      const previousMouseMoveTime = this.lastMouseMoveTime;
      this.lastMouseMoveTime = Date.now();
      
      // Cancel any pending glow animation trigger (but don't interrupt ongoing sequences)
      if (this.idleTimeout !== null) {
        clearTimeout(this.idleTimeout);
        this.idleTimeout = null;
      }
      
      // Only set up new glow trigger if not currently glowing (let ongoing sequences complete)
      if (!this.isGlowing) {
        // Set timeout to trigger glow sequence when mouse stops moving (pauses)
        // This will fire after mouse hasn't moved for 400ms
        this.idleTimeout = window.setTimeout(() => {
          // Check if mouse is still active and sequence isn't already running
          if (!this.isActive || this.isGlowing) return; // Don't trigger if mouse left or sequence already started
          const timeSinceLastMove = Date.now() - this.lastMouseMoveTime;
          if (timeSinceLastMove >= 350) {
            // Wait for transform transition to complete, then trigger glow
            setTimeout(() => {
              // Double-check mouse is still active, hasn't moved, and sequence isn't running
              if (!this.isActive || this.isGlowing) return; // Don't trigger if mouse left or sequence already started
              const finalCheck = Date.now() - this.lastMouseMoveTime;
              if (finalCheck >= 400) {
                this.triggerGlowSequence();
              }
            }, 150);
          }
        }, 400); // 400ms after last mouse movement
      }
    }

    handleMouseLeave() {
      this.isActive = false;
      if (this.idleTimeout !== null) {
        clearTimeout(this.idleTimeout);
        this.idleTimeout = null;
      }
      this.elements.forEach(el => {
        // Use translateZ(0) to maintain hardware acceleration layer
        el.style.transform = 'translate3d(0, 0, 0)';
        // Remove will-change after transition completes to restore normal rendering
        setTimeout(() => {
          el.style.willChange = 'auto';
        }, 150); // After transition completes
      });
    }

    removeAllGlows() {
      const words = document.querySelectorAll('.word-stupid, .word-web, .word-tricks');
      words.forEach(word => word.classList.remove('glow'));
      this.isGlowing = false;
    }

    triggerGlowSequence() {
      // Don't trigger if already glowing or if mouse is not active (text returning to center)
      if (this.isGlowing || !this.isActive) return;
      this.isGlowing = true;

      const wordStupid = document.querySelector('.word-stupid');
      const wordWeb = document.querySelector('.word-web');
      const wordTricks = document.querySelector('.word-tricks');

      // Glow STUPID, then fade completely before starting WEB
      if (wordStupid) {
        wordStupid.classList.add('glow');
        
        // Wait for STUPID to complete glow and fade (300ms animation + small buffer)
        setTimeout(() => {
          wordStupid.classList.remove('glow');
          
          // Start WEB glow after STUPID has fully finished
          setTimeout(() => {
            if (wordWeb) {
              wordWeb.classList.add('glow');
              
              // Wait for WEB to complete glow and fade
              setTimeout(() => {
                wordWeb.classList.remove('glow');
                
                // Start TRICKS glow after WEB has fully finished
                setTimeout(() => {
                  if (wordTricks) {
                    wordTricks.classList.add('glow');
                    
                    // Wait for TRICKS to complete glow and fade, then add 500ms delay before allowing next trigger
                    setTimeout(() => {
                      wordTricks.classList.remove('glow');
                      // Wait 500ms after sequence completes before allowing it to be triggered again
                      setTimeout(() => {
                        this.isGlowing = false;
                      }, 500);
                    }, 300); // Animation duration
                  } else {
                    // If TRICKS word not found, still add 500ms delay
                    setTimeout(() => {
                      this.isGlowing = false;
                    }, 500);
                  }
                }, 50); // Small buffer between words
              }, 300); // Animation duration
            } else {
              // If WEB word not found, add 500ms delay
              setTimeout(() => {
                this.isGlowing = false;
              }, 500);
            }
          }, 50); // Small buffer between words
        }, 300); // Animation duration (matches CSS animation)
      } else {
        // If STUPID word not found, add 500ms delay
        setTimeout(() => {
          this.isGlowing = false;
        }, 500);
      }
    }

    animate() {
      if (this.isActive) {
        this.elements.forEach(el => {
          const rect = el.getBoundingClientRect();
          const centerX = rect.left + rect.width / 2;
          const centerY = rect.top + rect.height / 2;
          
          const deltaX = (this.mouseX - centerX) * 0.15;
          const deltaY = (this.mouseY - centerY) * 0.15;
          const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
          
          if (distance < 150) {
            const rotateX = (deltaY / 150) * 5;
            const rotateY = (deltaX / 150) * -5;
            el.style.transform = `translate3d(${deltaX}px, ${deltaY}px, 0) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
          } else {
            el.style.transform = 'translate3d(0, 0, 0)';
          }
        });
      } else {
        // When inactive, check if we should trigger glow after transform settles
        const timeSinceLastMove = Date.now() - this.lastMouseMoveTime;
        if (timeSinceLastMove >= 350 && !this.isGlowing && this.lastMouseMoveTime > 0) {
          this.triggerGlowSequence();
          this.lastMouseMoveTime = 0; // Reset to prevent retriggering
        }
      }
      
      this.animationFrame = requestAnimationFrame(() => this.animate());
    }

    destroy() {
      if (this.animationFrame !== null) {
        cancelAnimationFrame(this.animationFrame);
      }
      const heroSection = document.querySelector('.hero-section');
      if (heroSection) {
        heroSection.removeEventListener('mousemove', this.mouseMoveHandler);
        heroSection.removeEventListener('mouseleave', this.mouseLeaveHandler);
      }
      this.elements = [];
    }
  }

  // Particle interface
  interface Particle {
    x: number;
    y: number;
    vx: number;
    vy: number;
    life: number;
    maxLife: number;
    size: number;
    hue: number;
  }

  // Particle Trail Effect
  class ParticleTrail {
    private canvas: HTMLCanvasElement | null = null;
    private ctx: CanvasRenderingContext2D | null = null;
    private particles: Particle[] = [];
    private mouseX = 0;
    private mouseY = 0;
    private lastMouseX = 0;
    private lastMouseY = 0;
    private isActive = false;
    private animationFrame: number | null = null;
    private mouseMoveHandler: (e: MouseEvent) => void;
    private mouseLeaveHandler: () => void;
    private resizeHandler: () => void;
    private maxParticles = 50; // Limit particles to prevent memory issues

    constructor() {
      this.mouseMoveHandler = (e: MouseEvent) => this.handleMouseMove(e);
      this.mouseLeaveHandler = () => this.handleMouseLeave();
      this.resizeHandler = () => this.resize();
    }

    init() {
      this.canvas = document.getElementById('particleTrail') as HTMLCanvasElement;
      if (!this.canvas) return;

      this.ctx = this.canvas.getContext('2d', { alpha: true });
      if (!this.ctx) return;

      this.resize();
      const heroSection = document.querySelector('.hero-section');
      if (heroSection) {
        heroSection.addEventListener('mousemove', this.mouseMoveHandler);
        heroSection.addEventListener('mouseleave', this.mouseLeaveHandler);
      }
      window.addEventListener('resize', this.resizeHandler);
      this.animate();
    }

    resize() {
      if (!this.canvas) return;
      this.canvas.width = window.innerWidth;
      this.canvas.height = window.innerHeight;
    }

    handleMouseMove(e: MouseEvent) {
      this.lastMouseX = this.mouseX;
      this.lastMouseY = this.mouseY;
      this.mouseX = e.clientX;
      this.mouseY = e.clientY;
      this.isActive = true;

      // Create particles at mouse position
      if (this.particles.length < this.maxParticles) {
        const speed = Math.sqrt(
          Math.pow(this.mouseX - this.lastMouseX, 2) + 
          Math.pow(this.mouseY - this.lastMouseY, 2)
        );
        
        for (let i = 0; i < Math.min(3, Math.floor(speed / 5)); i++) {
          this.createParticle();
        }
      }
    }

    handleMouseLeave() {
      this.isActive = false;
    }

    createParticle() {
      if (this.particles.length >= this.maxParticles || !this.ctx) return;

      this.particles.push({
        x: this.mouseX + (Math.random() - 0.5) * 10,
        y: this.mouseY + (Math.random() - 0.5) * 10,
        vx: (Math.random() - 0.5) * 2,
        vy: (Math.random() - 0.5) * 2,
        life: 60,
        maxLife: 60,
        size: Math.random() * 3 + 2,
        hue: Math.random() * 60 + 180 // Blue-purple range
      });
    }

    animate() {
      if (!this.ctx || !this.canvas) return;

      // Clear canvas with transparent background (don't use black fade)
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

      // Update and draw particles
      this.particles = this.particles.filter(particle => {
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.vx *= 0.95;
        particle.vy *= 0.95;
        particle.life--;

        if (particle.life <= 0 || !this.ctx) return false;

        const alpha = particle.life / particle.maxLife;
        this.ctx.globalAlpha = alpha;
        this.ctx.fillStyle = `hsl(${particle.hue}, 70%, 60%)`;
        this.ctx.beginPath();
        this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
        this.ctx.fill();

        return true;
      });

      if (this.ctx) {
        this.ctx.globalAlpha = 1;
      }
      this.animationFrame = requestAnimationFrame(() => this.animate());
    }

    destroy() {
      if (this.animationFrame !== null) {
        cancelAnimationFrame(this.animationFrame);
        this.animationFrame = null;
      }
      const heroSection = document.querySelector('.hero-section');
      if (heroSection) {
        heroSection.removeEventListener('mousemove', this.mouseMoveHandler);
        heroSection.removeEventListener('mouseleave', this.mouseLeaveHandler);
      }
      window.removeEventListener('resize', this.resizeHandler);
      this.particles = [];
      if (this.ctx && this.canvas) {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      }
    }
  }

  // Initialize effects
  let magneticText: MagneticText | null = null;
  let particleTrail: ParticleTrail | null = null;

  document.addEventListener('DOMContentLoaded', () => {
    magneticText = new MagneticText();
    magneticText.init();

    particleTrail = new ParticleTrail();
    particleTrail.init();
  });

  // Cleanup on page unload
  window.addEventListener('beforeunload', () => {
    if (magneticText) {
      magneticText.destroy();
      magneticText = null;
    }
    if (particleTrail) {
      particleTrail.destroy();
      particleTrail = null;
    }
  });
</script>

<style>
  /* Hero button styling */
  .hero-button {
    position: relative;
    z-index: 50;
    will-change: transform;
  }

  /* Content wrapper - isolates text from background blobs */
  .content-wrapper::before {
    content: '';
    position: absolute;
    inset: -50px;
    background: radial-gradient(ellipse at center, rgba(0, 0, 0, 0.2) 0%, transparent 70%);
    backdrop-filter: blur(1px);
    z-index: -1;
    pointer-events: none;
  }

  /* Magnetic text styling */
  .magnetic-text {
    display: inline-block;
    transition: transform 0.1s ease-out;
    will-change: transform;
    transform-style: preserve-3d;
    color: #7661d1 !important;
    filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.6)) drop-shadow(0 0 8px rgba(118, 97, 209, 0.4));
    -webkit-text-stroke: 1px rgba(255, 255, 255, 0.1);
  }
  
  /* Smooth transition only when actively transforming */
  .magnetic-text[style*="rotate"] {
    transition: transform 0.08s ease-out;
  }

  /* Word styling */
  .word {
    display: inline-block;
    transition: text-shadow 0.5s ease-in-out;
  }

  /* Glow animation for words - white glow flash effect */
  .word.glow {
    filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.6)) drop-shadow(0 0 20px rgba(255, 255, 255, 0.9)) drop-shadow(0 0 40px rgba(255, 255, 255, 0.7)) drop-shadow(0 0 60px rgba(255, 255, 255, 0.5)) !important;
    animation: flashGlow 0.3s ease-in-out;
  }

  @keyframes flashGlow {
    0% {
      filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.6)) drop-shadow(0 0 8px rgba(118, 97, 209, 0.4)) !important;
    }
    50% {
      filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.6)) drop-shadow(0 0 30px rgba(255, 255, 255, 1)) drop-shadow(0 0 50px rgba(255, 255, 255, 0.9)) drop-shadow(0 0 70px rgba(255, 255, 255, 0.8)) drop-shadow(0 0 90px rgba(255, 255, 255, 0.6)) !important;
    }
    100% {
      filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.6)) drop-shadow(0 0 8px rgba(118, 97, 209, 0.4)) !important;
    }
  }

  /* Liquid blob animations */
  .liquid-blobs {
    filter: blur(40px);
    opacity: 0.9;
    z-index: 1;
  }

  .blob {
    position: absolute;
    border-radius: 50%;
    will-change: transform;
    z-index: 1;
  }

  .blob-1 {
    width: 800px;
    height: 800px;
    background: radial-gradient(circle, rgba(147, 51, 234, 0.95), rgba(79, 70, 229, 0.85));
    top: 5%;
    left: 0%;
    animation: blobFloat1 20s ease-in-out infinite;
  }

  .blob-2 {
    width: 900px;
    height: 900px;
    background: radial-gradient(circle, rgba(79, 70, 229, 0.95), rgba(59, 130, 246, 0.85));
    bottom: 5%;
    right: 0%;
    animation: blobFloat2 25s ease-in-out infinite;
  }

  .blob-3 {
    width: 700px;
    height: 700px;
    background: radial-gradient(circle, rgba(59, 130, 246, 0.9), rgba(37, 99, 235, 0.75));
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    animation: blobFloat3 30s ease-in-out infinite;
  }

  @keyframes blobFloat1 {
    0%, 100% { transform: translate(0, 0) scale(1) rotate(0deg); }
    33% { transform: translate(120px, 80px) scale(1.2) rotate(120deg); }
    66% { transform: translate(-60px, 100px) scale(0.9) rotate(240deg); }
  }

  @keyframes blobFloat2 {
    0%, 100% { transform: translate(0, 0) scale(1) rotate(0deg); }
    33% { transform: translate(-100px, -120px) scale(1.3) rotate(120deg); }
    66% { transform: translate(120px, -60px) scale(0.85) rotate(240deg); }
  }

  @keyframes blobFloat3 {
    0%, 100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
    33% { transform: translate(-45%, -60%) scale(1.3) rotate(120deg); }
    66% { transform: translate(-55%, -40%) scale(0.8) rotate(240deg); }
  }

  /* Floating shapes canvas - behind particles but above background */
  #floatingShapesCanvas {
    z-index: 4;
  }

  /* Particle canvas - on top so particles are visible */
  #particleTrail {
    z-index: 5;
  }
</style>
