---
// HeroSection.astro - Main hero section with magnetic text, particle trail, and liquid blobs
import FloatingShapesCanvas from '../features/FloatingShapesCanvas.astro';
---

<section class="hero-section relative h-[calc(100vh-4rem)] flex items-center justify-center overflow-hidden">
  <!-- Liquid blob background -->
  <div class="absolute inset-0 bg-gradient-to-br from-purple-900 via-blue-900 to-indigo-900">
    <div class="liquid-blobs absolute inset-0">
      <div class="blob blob-1"></div>
      <div class="blob blob-2"></div>
      <div class="blob blob-3"></div>
    </div>
  </div>

  <!-- Floating shapes canvas -->
  <FloatingShapesCanvas />
  
  <!-- Particle trail canvas -->
  <canvas id="particleTrail" class="absolute inset-0 w-full h-full pointer-events-none"></canvas>
  
  <!-- Content -->
  <div class="relative z-10 text-center px-4 sm:px-6 lg:px-8 max-w-4xl mx-auto content-wrapper" style="isolation: isolate;">
    <h1 class="hero-title text-5xl sm:text-6xl lg:text-7xl font-bold mb-6 animate-slide-up bangers-font" style="text-shadow: 2px 2px 4px rgba(0,0,0,0.3), 0 0 20px rgba(0,0,0,0.5); text-transform: none; letter-spacing: 3px;">
      <span class="magnetic-text" data-text="Stupid Web Tricks" style="color: #7661d1 !important; text-shadow: 2px 2px 4px rgba(0,0,0,0.5), 0 0 10px rgba(118, 97, 209, 0.3) !important;">
        <span class="word word-stupid">Stupid</span> <span class="word word-web">Web</span> <span class="word word-tricks">Tricks</span>
      </span>
    </h1>
    <p class="text-xl sm:text-2xl text-gray-300 mb-8 animate-slide-up" style="animation-delay: 0.2s;">
      Discover amazing web effects, animations,<br>
      and learn the techniques to create them!
    </p>
    <div class="animate-slide-up" style="animation-delay: 0.4s;">
      <a href="#categories" class="hero-button inline-flex items-center px-8 py-4 bg-gradient-to-r from-purple-600 to-blue-600 text-white font-semibold rounded-full hover:from-purple-700 hover:to-blue-700 transform hover:scale-105 transition-all duration-300 shadow-lg hover:shadow-xl cursor-pointer relative z-50">
        Explore Tricks
        <svg class="ml-2 w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
        </svg>
      </a>
    </div>
  </div>
</section>

<script>
  // Magnetic Text Effect
  class MagneticText {
    private elements: HTMLElement[] = [];
    private mouseX = 0;
    private mouseY = 0;
    private isActive = false;
    private lastMouseMoveTime = 0;
    private idleTimeout: number | null = null;
    private isGlowing = false;
    private animationFrame: number | null = null;
    private mouseMoveHandler: (e: MouseEvent) => void;
    private mouseLeaveHandler: () => void;
    private isDestroyed: boolean = false; // Flag to prevent timeout execution after destroy

    constructor() {
      this.mouseMoveHandler = (e: MouseEvent) => this.handleMouseMove(e);
      this.mouseLeaveHandler = () => this.handleMouseLeave();
    }

    init() {
      this.elements = Array.from(document.querySelectorAll<HTMLElement>('.magnetic-text'));
      if (this.elements.length === 0) return;

      const heroSection = document.querySelector('.hero-section');
      if (!heroSection) return;

      heroSection.addEventListener('mousemove', this.mouseMoveHandler);
      heroSection.addEventListener('mouseleave', this.mouseLeaveHandler);
      this.animate();
    }

    handleMouseMove(e: MouseEvent) {
      this.mouseX = e.clientX;
      this.mouseY = e.clientY;
      this.isActive = true;
      const previousMouseMoveTime = this.lastMouseMoveTime;
      this.lastMouseMoveTime = Date.now();
      
      // Cancel any pending glow animation trigger (but don't interrupt ongoing sequences)
      if (this.idleTimeout !== null) {
        clearTimeout(this.idleTimeout);
        this.idleTimeout = null;
      }
      
      // Only set up new glow trigger if not currently glowing (let ongoing sequences complete)
      if (!this.isGlowing) {
        // Set timeout to trigger glow sequence when mouse stops moving (pauses)
        // This will fire after mouse hasn't moved for 400ms
        this.idleTimeout = window.setTimeout(() => {
          // Check if mouse is still active and sequence isn't already running
          if (!this.isActive || this.isGlowing) return; // Don't trigger if mouse left or sequence already started
          const timeSinceLastMove = Date.now() - this.lastMouseMoveTime;
          if (timeSinceLastMove >= 350) {
            // Wait for transform transition to complete, then trigger glow
            setTimeout(() => {
              // Double-check mouse is still active, hasn't moved, and sequence isn't running
              if (this.isDestroyed || !this.isActive || this.isGlowing) return; // Don't trigger if destroyed, mouse left, or sequence already started
              const finalCheck = Date.now() - this.lastMouseMoveTime;
              if (finalCheck >= 400) {
                this.triggerGlowSequence();
              }
            }, 150);
          }
        }, 400); // 400ms after last mouse movement
      }
    }

    handleMouseLeave() {
      this.isActive = false;
      if (this.idleTimeout !== null) {
        clearTimeout(this.idleTimeout);
        this.idleTimeout = null;
      }
      this.elements.forEach(el => {
        // Use translateZ(0) to maintain hardware acceleration layer
        el.style.transform = 'translate3d(0, 0, 0)';
        // Remove will-change after transition completes to restore normal rendering
        setTimeout(() => {
          if (!this.isDestroyed) {
            el.style.willChange = 'auto';
          }
        }, 150); // After transition completes
      });
    }

    removeAllJiggles() {
      const words = document.querySelectorAll('.word-stupid, .word-web, .word-tricks');
      words.forEach(word => word.classList.remove('jiggle'));
      this.isGlowing = false;
    }

    triggerGlowSequence(force = false) {
      // Don't trigger if already jiggling or destroyed
      if (this.isGlowing || this.isDestroyed) return;
      // Don't trigger if mouse is not active (unless forced, e.g., on page load)
      if (!force && !this.isActive) return;
      this.isGlowing = true;

      const wordStupid = document.querySelector('.word-stupid');
      const wordWeb = document.querySelector('.word-web');
      const wordTricks = document.querySelector('.word-tricks');

      // Jiggle STUPID, then stop completely before starting WEB
      if (wordStupid) {
        wordStupid.classList.add('jiggle');
        
        // Wait for STUPID to complete jiggle (300ms animation)
        setTimeout(() => {
          if (this.isDestroyed) return;
          wordStupid.classList.remove('jiggle');
          
          // Start WEB jiggle after STUPID has fully finished
          setTimeout(() => {
            if (this.isDestroyed) return;
            if (wordWeb) {
              wordWeb.classList.add('jiggle');
              
              // Wait for WEB to complete jiggle
              setTimeout(() => {
                if (this.isDestroyed) return;
                wordWeb.classList.remove('jiggle');
                
                // Start TRICKS jiggle after WEB has fully finished
                setTimeout(() => {
                  if (this.isDestroyed) return;
                  if (wordTricks) {
                    wordTricks.classList.add('jiggle');
                    
                    // Wait for TRICKS to complete jiggle, then add 500ms delay before allowing next trigger
                    setTimeout(() => {
                      if (this.isDestroyed) return;
                      wordTricks.classList.remove('jiggle');
                      // Wait 500ms after sequence completes before allowing it to be triggered again
                      setTimeout(() => {
                        if (!this.isDestroyed) this.isGlowing = false;
                      }, 500);
                    }, 300); // Animation duration
                  } else {
                    // If TRICKS word not found, still add 500ms delay
                    setTimeout(() => {
                      if (!this.isDestroyed) this.isGlowing = false;
                    }, 500);
                  }
                }, 50); // Small buffer between words
              }, 300); // Animation duration
            } else {
              // If WEB word not found, add 500ms delay
              setTimeout(() => {
                if (!this.isDestroyed) this.isGlowing = false;
              }, 500);
            }
          }, 50); // Small buffer between words
        }, 300); // Animation duration (matches CSS animation)
      } else {
        // If STUPID word not found, add 500ms delay
        setTimeout(() => {
          if (!this.isDestroyed) this.isGlowing = false;
        }, 500);
      }
    }

    animate() {
      if (this.isActive) {
        this.elements.forEach(el => {
          const rect = el.getBoundingClientRect();
          const centerX = rect.left + rect.width / 2;
          const centerY = rect.top + rect.height / 2;
          
          const deltaX = (this.mouseX - centerX) * 0.15;
          const deltaY = (this.mouseY - centerY) * 0.15;
          const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
          
          if (distance < 150) {
            const rotateX = (deltaY / 150) * 5;
            const rotateY = (deltaX / 150) * -5;
            el.style.transform = `translate3d(${deltaX}px, ${deltaY}px, 0) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
          } else {
            el.style.transform = 'translate3d(0, 0, 0)';
          }
        });
      } else {
        // When inactive, check if we should trigger glow after transform settles
        const timeSinceLastMove = Date.now() - this.lastMouseMoveTime;
        if (timeSinceLastMove >= 350 && !this.isGlowing && this.lastMouseMoveTime > 0) {
          this.triggerGlowSequence();
          this.lastMouseMoveTime = 0; // Reset to prevent retriggering
        }
      }
      
      this.animationFrame = requestAnimationFrame(() => this.animate());
    }

    destroy() {
      // Mark as destroyed to prevent timeout execution
      this.isDestroyed = true;
      
      // Cancel animation frame
      if (this.animationFrame !== null) {
        cancelAnimationFrame(this.animationFrame);
        this.animationFrame = null;
      }
      
      // Cancel idle timeout
      if (this.idleTimeout !== null) {
        clearTimeout(this.idleTimeout);
        this.idleTimeout = null;
      }
      
      // Remove event listeners
      const heroSection = document.querySelector('.hero-section');
      if (heroSection) {
        heroSection.removeEventListener('mousemove', this.mouseMoveHandler);
        heroSection.removeEventListener('mouseleave', this.mouseLeaveHandler);
      }
      
      this.elements = [];
    }
  }

  // Particle interface - now represents tiny soap bubbles
  interface Particle {
    x: number;
    y: number;
    vx: number;
    vy: number;
    life: number;
    maxLife: number;
    radius: number; // Size/radius of the bubble
    colors: string[]; // Iridescent colors for the bubble
    reflectionAngle: number; // For reflection positioning
    pulse: number; // Subtle pulse animation
  }

  // Particle Trail Effect
  class ParticleTrail {
    private canvas: HTMLCanvasElement | null = null;
    private ctx: CanvasRenderingContext2D | null = null;
    private particles: Particle[] = [];
    private mouseX = 0;
    private mouseY = 0;
    private lastMouseX = 0;
    private lastMouseY = 0;
    private isActive = false;
    private animationFrame: number | null = null;
    private mouseMoveHandler: (e: MouseEvent) => void;
    private mouseLeaveHandler: () => void;
    private resizeHandler: () => void;
    private maxParticles = 50; // Limit particles to prevent memory issues

    constructor() {
      this.mouseMoveHandler = (e: MouseEvent) => this.handleMouseMove(e);
      this.mouseLeaveHandler = () => this.handleMouseLeave();
      this.resizeHandler = () => this.resize();
    }

    init() {
      this.canvas = document.getElementById('particleTrail') as HTMLCanvasElement;
      if (!this.canvas) return;

      this.ctx = this.canvas.getContext('2d', { alpha: true });
      if (!this.ctx) return;

      this.resize();
      const heroSection = document.querySelector('.hero-section');
      if (heroSection) {
        heroSection.addEventListener('mousemove', this.mouseMoveHandler);
        heroSection.addEventListener('mouseleave', this.mouseLeaveHandler);
      }
      window.addEventListener('resize', this.resizeHandler);
      this.animate();
    }

    resize() {
      if (!this.canvas) return;
      this.canvas.width = window.innerWidth;
      this.canvas.height = window.innerHeight;
    }

    handleMouseMove(e: MouseEvent) {
      this.lastMouseX = this.mouseX;
      this.lastMouseY = this.mouseY;
      this.mouseX = e.clientX;
      this.mouseY = e.clientY;
      this.isActive = true;

      // Create particles at mouse position
      if (this.particles.length < this.maxParticles) {
        const speed = Math.sqrt(
          Math.pow(this.mouseX - this.lastMouseX, 2) + 
          Math.pow(this.mouseY - this.lastMouseY, 2)
        );
        
        for (let i = 0; i < Math.min(3, Math.floor(speed / 5)); i++) {
          this.createParticle();
        }
      }
    }

    handleMouseLeave() {
      this.isActive = false;
    }

    createParticle() {
      if (this.particles.length >= this.maxParticles || !this.ctx) return;

      // Use same soap bubble color sets as big bubbles
      const soapBubbleColorSets = [
        ['rgba(255, 230, 250, 0.15)', 'rgba(230, 250, 255, 0.18)', 'rgba(240, 255, 255, 0.12)'],
        ['rgba(240, 230, 255, 0.16)', 'rgba(230, 240, 255, 0.17)', 'rgba(230, 255, 250, 0.14)'],
        ['rgba(230, 245, 255, 0.17)', 'rgba(240, 255, 255, 0.16)', 'rgba(255, 240, 250, 0.15)'],
        ['rgba(235, 255, 240, 0.15)', 'rgba(230, 245, 255, 0.17)', 'rgba(245, 235, 255, 0.16)'],
        ['rgba(255, 250, 235, 0.14)', 'rgba(255, 235, 245, 0.16)', 'rgba(235, 245, 255, 0.15)'],
        ['rgba(235, 255, 255, 0.16)', 'rgba(245, 235, 255, 0.15)', 'rgba(255, 235, 250, 0.17)']
      ];

      const randomColors = soapBubbleColorSets[Math.floor(Math.random() * soapBubbleColorSets.length)];

      this.particles.push({
        x: this.mouseX + (Math.random() - 0.5) * 10,
        y: this.mouseY + (Math.random() - 0.5) * 10,
        vx: (Math.random() - 0.5) * 1.5,
        vy: (Math.random() - 0.5) * 1.5,
        life: 80, // Longer life for tiny bubbles
        maxLife: 80,
        radius: Math.random() * 4 + 3, // Tiny bubbles: 3-7px radius
        colors: randomColors,
        reflectionAngle: Math.random() * 0.3 - 0.15, // Small reflection offset
        pulse: Math.random() * Math.PI * 2 // Random pulse phase
      });
    }

    animate() {
      if (!this.ctx || !this.canvas) return;

      // Clear canvas with transparent background
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

      // Update and draw tiny bubbles
      this.particles = this.particles.filter(particle => {
        particle.x += particle.vx;
        particle.y += particle.vy;
        particle.vx *= 0.96;
        particle.vy *= 0.96;
        particle.life--;
        particle.pulse += 0.05; // Subtle pulse animation

        if (particle.life <= 0 || !this.ctx) return false;

        const alpha = particle.life / particle.maxLife;
        const pulseSize = particle.radius + Math.sin(particle.pulse) * 0.3;
        
        this.ctx.save();
        
        // Create bubble path (perfect circle)
        const bubblePath = new Path2D();
        bubblePath.arc(particle.x, particle.y, pulseSize, 0, Math.PI * 2);
        bubblePath.closePath();
        
        // Draw main bubble body with iridescent gradient
        if (particle.colors && particle.colors.length >= 3) {
          const mainGradient = this.ctx.createRadialGradient(
            particle.x - pulseSize * 0.35, particle.y - pulseSize * 0.35, 0,
            particle.x, particle.y, pulseSize
          );
          mainGradient.addColorStop(0, `rgba(255, 255, 255, ${0.02 * alpha})`);
          mainGradient.addColorStop(0.7, this.adjustAlpha(particle.colors[0], alpha));
          mainGradient.addColorStop(0.85, this.adjustAlpha(particle.colors[1], alpha));
          mainGradient.addColorStop(1, this.adjustAlpha(particle.colors[2], alpha));
          
          this.ctx.fillStyle = mainGradient;
          this.ctx.fill(bubblePath);
        }
        
        // Skip reflections - too prominent for tiny bubbles
        
        // Soft border/outline
        this.ctx.shadowBlur = 5;
        this.ctx.shadowColor = `rgba(255, 255, 255, ${0.35 * alpha})`;
        this.ctx.shadowOffsetX = 0;
        this.ctx.shadowOffsetY = 0;
        this.ctx.strokeStyle = `rgba(255, 255, 255, ${0.25 * alpha})`;
        this.ctx.lineWidth = 0.3;
        this.ctx.stroke(bubblePath);
        
        // Reset shadow
        this.ctx.shadowBlur = 0;
        this.ctx.shadowColor = 'transparent';
        
        // Subtle inner edge
        this.ctx.strokeStyle = `rgba(255, 255, 255, ${0.1 * alpha})`;
        this.ctx.lineWidth = 0.2;
        this.ctx.stroke(bubblePath);
        
        this.ctx.restore();

        return true;
      });

      if (this.ctx) {
        this.ctx.globalAlpha = 1;
      }
      this.animationFrame = requestAnimationFrame(() => this.animate());
    }

    // Helper to adjust alpha in rgba color strings
    adjustAlpha(color: string, alpha: number): string {
      // Match rgba values - format is rgba(r, g, b, a) where a is 0-1
      const match = color.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/);
      if (match) {
        const r = match[1];
        const g = match[2];
        const b = match[3];
        const originalAlpha = parseFloat(match[4]);
        return `rgba(${r}, ${g}, ${b}, ${originalAlpha * alpha})`;
      }
      return color;
    }

    destroy() {
      if (this.animationFrame !== null) {
        cancelAnimationFrame(this.animationFrame);
        this.animationFrame = null;
      }
      const heroSection = document.querySelector('.hero-section');
      if (heroSection) {
        heroSection.removeEventListener('mousemove', this.mouseMoveHandler);
        heroSection.removeEventListener('mouseleave', this.mouseLeaveHandler);
      }
      window.removeEventListener('resize', this.resizeHandler);
      this.particles = [];
      if (this.ctx && this.canvas) {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      }
    }
  }

  // Initialize effects
  let magneticText: MagneticText | null = null;
  let particleTrail: ParticleTrail | null = null;

  document.addEventListener('DOMContentLoaded', () => {
    magneticText = new MagneticText();
    magneticText.init();

    particleTrail = new ParticleTrail();
    particleTrail.init();

    // Trigger initial jiggle sequence on page load
    setTimeout(() => {
      if (magneticText) {
        magneticText.triggerGlowSequence(true); // force = true to bypass isActive check
      }
    }, 500); // Small delay to ensure page is fully loaded
  });

  // Cleanup on page unload
  window.addEventListener('beforeunload', () => {
    if (magneticText) {
      magneticText.destroy();
      magneticText = null;
    }
    if (particleTrail) {
      particleTrail.destroy();
      particleTrail = null;
    }
  });
</script>

<style>
  /* Hero button styling */
  .hero-button {
    position: relative;
    z-index: 50;
    will-change: transform;
  }

  /* Content wrapper - isolates text from background blobs */
  .content-wrapper::before {
    content: '';
    position: absolute;
    inset: -50px;
    background: radial-gradient(ellipse at center, rgba(0, 0, 0, 0.2) 0%, transparent 70%);
    backdrop-filter: blur(1px);
    z-index: -1;
    pointer-events: none;
  }

  /* Magnetic text styling */
  .magnetic-text {
    display: inline-block;
    transition: transform 0.1s ease-out;
    will-change: transform;
    transform-style: preserve-3d;
    color: #7661d1 !important;
    filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.6)) drop-shadow(0 0 8px rgba(118, 97, 209, 0.4));
    -webkit-text-stroke: 1px rgba(255, 255, 255, 0.1);
  }
  
  /* Smooth transition only when actively transforming */
  .magnetic-text[style*="rotate"] {
    transition: transform 0.08s ease-out;
  }

  /* Word styling */
  .word {
    display: inline-block;
    transition: text-shadow 0.5s ease-in-out;
  }

  /* Jiggle animation for words */
  .word.jiggle {
    animation: jiggle 0.3s ease-in-out;
  }

  @keyframes jiggle {
    0%, 100% {
      transform: translateX(0) translateY(0) rotate(0deg);
    }
    10% {
      transform: translateX(-2px) translateY(-1px) rotate(-1deg);
    }
    20% {
      transform: translateX(2px) translateY(1px) rotate(1deg);
    }
    30% {
      transform: translateX(-1px) translateY(1px) rotate(-0.5deg);
    }
    40% {
      transform: translateX(1px) translateY(-1px) rotate(0.5deg);
    }
    50% {
      transform: translateX(-1px) translateY(-1px) rotate(-0.5deg);
    }
    60% {
      transform: translateX(1px) translateY(1px) rotate(0.5deg);
    }
    70% {
      transform: translateX(-1px) translateY(0px) rotate(-0.3deg);
    }
    80% {
      transform: translateX(1px) translateY(0px) rotate(0.3deg);
    }
    90% {
      transform: translateX(0px) translateY(0px) rotate(0deg);
    }
  }

  /* Liquid blob animations */
  .liquid-blobs {
    filter: blur(40px);
    opacity: 0.9;
    z-index: 1;
  }

  .blob {
    position: absolute;
    border-radius: 50%;
    will-change: transform;
    z-index: 1;
  }

  .blob-1 {
    width: 800px;
    height: 800px;
    background: radial-gradient(circle, rgba(147, 51, 234, 0.95), rgba(79, 70, 229, 0.85));
    top: 5%;
    left: 0%;
    animation: blobFloat1 20s ease-in-out infinite;
  }

  .blob-2 {
    width: 900px;
    height: 900px;
    background: radial-gradient(circle, rgba(79, 70, 229, 0.95), rgba(59, 130, 246, 0.85));
    bottom: 5%;
    right: 0%;
    animation: blobFloat2 25s ease-in-out infinite;
  }

  .blob-3 {
    width: 700px;
    height: 700px;
    background: radial-gradient(circle, rgba(59, 130, 246, 0.9), rgba(37, 99, 235, 0.75));
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    animation: blobFloat3 30s ease-in-out infinite;
  }

  @keyframes blobFloat1 {
    0%, 100% { transform: translate(0, 0) scale(1) rotate(0deg); }
    33% { transform: translate(120px, 80px) scale(1.2) rotate(120deg); }
    66% { transform: translate(-60px, 100px) scale(0.9) rotate(240deg); }
  }

  @keyframes blobFloat2 {
    0%, 100% { transform: translate(0, 0) scale(1) rotate(0deg); }
    33% { transform: translate(-100px, -120px) scale(1.3) rotate(120deg); }
    66% { transform: translate(120px, -60px) scale(0.85) rotate(240deg); }
  }

  @keyframes blobFloat3 {
    0%, 100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
    33% { transform: translate(-45%, -60%) scale(1.3) rotate(120deg); }
    66% { transform: translate(-55%, -40%) scale(0.8) rotate(240deg); }
  }

  /* Floating shapes canvas - behind particles but above background */
  #floatingShapesCanvas {
    z-index: 4;
  }

  /* Particle canvas - on top so particles are visible */
  #particleTrail {
    z-index: 5;
  }
</style>
