---
// HeroSection.astro - Main hero section with magnetic text, particle trail, and liquid blobs
import FloatingShapesCanvas from '../features/FloatingShapesCanvas.astro';
import SoundEffectsProvider from '../providers/SoundEffectsProvider';
---

<section class="hero-section relative h-[calc(100vh-4rem)] flex items-center justify-center overflow-hidden">
  <SoundEffectsProvider client:load />
  <!-- Liquid blob background -->
  <div class="absolute inset-0 bg-gradient-to-br from-purple-900 via-blue-900 to-indigo-900">
    <div class="liquid-blobs absolute inset-0">
      <div class="blob blob-1"></div>
      <div class="blob blob-2"></div>
      <div class="blob blob-3"></div>
    </div>
  </div>

  <!-- Floating shapes canvas -->
  <FloatingShapesCanvas />
  
  <!-- Particle trail canvas -->
  <canvas id="particleTrail" class="absolute inset-0 w-full h-full pointer-events-none"></canvas>
  <!-- Laser overlay canvas -->
  <canvas id="heroLaser" class="absolute inset-0 w-full h-full pointer-events-none z-40 block" style="opacity: 0;"></canvas>
  
  <!-- Content -->
  <div class="relative z-10 text-center px-4 sm:px-6 lg:px-8 max-w-4xl mx-auto content-wrapper" style="isolation: isolate;">
    <h1 class="hero-title text-5xl sm:text-6xl lg:text-7xl font-bold mb-6 animate-slide-up bangers-font" style="text-shadow: 2px 2px 4px rgba(0,0,0,0.3), 0 0 20px rgba(0,0,0,0.5); text-transform: none; letter-spacing: 3px;">
      <span class="magnetic-text" data-text="Stupid Web Tricks" style="color: #7661d1 !important; text-shadow: 2px 2px 4px rgba(0,0,0,0.5), 0 0 10px rgba(118, 97, 209, 0.3) !important;">
        <span class="word word-stupid">Stupid</span> <span class="word word-web">Web</span> <span class="word word-tricks">Tricks</span>
      </span>
    </h1>
    <p class="hero-description text-xl sm:text-2xl text-gray-300 mb-8 animate-slide-up" style="animation-delay: 0.2s;">
      Discover amazing web effects, animations,<br>
      and learn the techniques to create them!
    </p>
    <div class="animate-slide-up" style="animation-delay: 0.4s;">
      <a href="#categories" class="hero-button inline-flex items-center px-8 py-4 bg-gradient-to-r from-purple-600 to-blue-600 text-white font-semibold rounded-full hover:from-purple-700 hover:to-blue-700 transform hover:scale-105 transition-all duration-300 shadow-lg hover:shadow-xl cursor-pointer relative z-50">
        Explore Tricks
        <svg class="ml-2 w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
        </svg>
      </a>
    </div>
  </div>
</section>

<script lang="js" is:inline>
  // Magnetic Text Effect
  class MagneticText {
    constructor() {
      this.elements = [];
      this.mouseX = 0;
      this.mouseY = 0;
      this.isActive = false;
      this.lastMouseMoveTime = 0;
      this.idleTimeout = null;
      this.isGlowing = false;
      this.animationFrame = null;
      this.isDestroyed = false; // Flag to prevent timeout execution after destroy

      this.mouseMoveHandler = (e) => this.handleMouseMove(e);
      this.mouseLeaveHandler = () => this.handleMouseLeave();
    }

    init() {
      this.elements = Array.from(document.querySelectorAll('.magnetic-text'));
      if (this.elements.length === 0) return;

      const heroSection = document.querySelector('.hero-section');
      if (!heroSection) return;

      heroSection.addEventListener('mousemove', this.mouseMoveHandler);
      heroSection.addEventListener('mouseleave', this.mouseLeaveHandler);
      this.animate();
    }

    handleMouseMove(e) {
      this.mouseX = e.clientX;
      this.mouseY = e.clientY;
      this.isActive = true;
      this.lastMouseMoveTime = Date.now();
      
      // Cancel any pending glow animation trigger (but don't interrupt ongoing sequences)
      if (this.idleTimeout !== null) {
        clearTimeout(this.idleTimeout);
        this.idleTimeout = null;
      }
      
      // Only set up new glow trigger if not currently glowing (let ongoing sequences complete)
      if (!this.isGlowing) {
        // Set timeout to trigger glow sequence when mouse stops moving (pauses)
        // This will fire after mouse hasn't moved for 400ms
        this.idleTimeout = window.setTimeout(() => {
          // Check if mouse is still active and sequence isn't already running
          if (!this.isActive || this.isGlowing) return; // Don't trigger if mouse left or sequence already started
          const timeSinceLastMove = Date.now() - this.lastMouseMoveTime;
          if (timeSinceLastMove >= 350) {
            // Wait for transform transition to complete, then trigger glow
            setTimeout(() => {
              // Double-check mouse is still active, hasn't moved, and sequence isn't running
              if (this.isDestroyed || !this.isActive || this.isGlowing) return; // Don't trigger if destroyed, mouse left, or sequence already started
              const finalCheck = Date.now() - this.lastMouseMoveTime;
              if (finalCheck >= 400) {
                this.triggerGlowSequence();
              }
            }, 150);
          }
        }, 400); // 400ms after last mouse movement
      }
    }

    handleMouseLeave() {
      this.isActive = false;
      if (this.idleTimeout !== null) {
        clearTimeout(this.idleTimeout);
        this.idleTimeout = null;
      }
      this.elements.forEach(el => {
        // Use translateZ(0) to maintain hardware acceleration layer
        el.style.transform = 'translate3d(0, 0, 0)';
        // Remove will-change after transition completes to restore normal rendering
        setTimeout(() => {
          if (!this.isDestroyed) {
            el.style.willChange = 'auto';
          }
        }, 150); // After transition completes
      });
    }

    removeAllJiggles() {
      const words = document.querySelectorAll('.word-stupid, .word-web, .word-tricks');
      words.forEach(word => word.classList.remove('jiggle'));
      this.isGlowing = false;
    }

    triggerGlowSequence(force = false) {
      // Don't trigger if already jiggling or destroyed
      if (this.isGlowing || this.isDestroyed) return;
      // Don't trigger if mouse is not active (unless forced, e.g., on page load)
      if (!force && !this.isActive) return;
      this.isGlowing = true;

      const wordStupid = document.querySelector('.word-stupid');
      const wordWeb = document.querySelector('.word-web');
      const wordTricks = document.querySelector('.word-tricks');

      // Jiggle STUPID, then stop completely before starting WEB
      if (wordStupid) {
        wordStupid.classList.add('jiggle');
        
        // Wait for STUPID to complete jiggle (300ms animation)
        setTimeout(() => {
          if (this.isDestroyed) return;
          wordStupid.classList.remove('jiggle');
          
          // Start WEB jiggle after STUPID has fully finished
          setTimeout(() => {
            if (this.isDestroyed) return;
            if (wordWeb) {
              wordWeb.classList.add('jiggle');
              
              // Wait for WEB to complete jiggle
              setTimeout(() => {
                if (this.isDestroyed) return;
                wordWeb.classList.remove('jiggle');
                
                // Start TRICKS jiggle after WEB has fully finished
                setTimeout(() => {
                  if (this.isDestroyed) return;
                  if (wordTricks) {
                    wordTricks.classList.add('jiggle');
                    
                    // Wait for TRICKS to complete jiggle, then add 500ms delay before allowing next trigger
                    setTimeout(() => {
                      if (this.isDestroyed) return;
                      wordTricks.classList.remove('jiggle');
                      // Wait 500ms after sequence completes before allowing it to be triggered again
                      setTimeout(() => {
                        if (!this.isDestroyed) this.isGlowing = false;
                      }, 500);
                    }, 300); // Animation duration
                  } else {
                    // If TRICKS word not found, still add 500ms delay
                    setTimeout(() => {
                      if (!this.isDestroyed) this.isGlowing = false;
                    }, 500);
                  }
                }, 50); // Small buffer between words
              }, 300); // Animation duration
            } else {
              // If WEB word not found, add 500ms delay
              setTimeout(() => {
                if (!this.isDestroyed) this.isGlowing = false;
              }, 500);
            }
          }, 50); // Small buffer between words
        }, 300); // Animation duration (matches CSS animation)
      } else {
        // If STUPID word not found, add 500ms delay
        setTimeout(() => {
          if (!this.isDestroyed) this.isGlowing = false;
        }, 500);
      }
    }

    pause() {
      this.isOnScreen = false;
    }

    resume() {
      this.isOnScreen = true;
    }

    animate() {
      if (this.isDestroyed || !this.isOnScreen) return;
      
      try {
        if (this.isActive) {
          this.elements.forEach(el => {
            const rect = el.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            const deltaX = (this.mouseX - centerX) * 0.15;
            const deltaY = (this.mouseY - centerY) * 0.15;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            
            if (distance < 150) {
              const rotateX = (deltaY / 150) * 5;
              const rotateY = (deltaX / 150) * -5;
              el.style.transform = `translate3d(${deltaX}px, ${deltaY}px, 0) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
            } else {
              el.style.transform = 'translate3d(0, 0, 0)';
            }
          });
        } else {
          // When inactive, check if we should trigger glow after transform settles
          const timeSinceLastMove = Date.now() - this.lastMouseMoveTime;
          if (timeSinceLastMove >= 350 && !this.isGlowing && this.lastMouseMoveTime > 0) {
            this.triggerGlowSequence();
            this.lastMouseMoveTime = 0; // Reset to prevent retriggering
          }
        }
        
        this.animationFrame = requestAnimationFrame(() => this.animate());
      } catch (error) {
        console.error('MagneticText: Error in animation loop:', error);
        // Continue the loop even if there's an error
        this.animationFrame = requestAnimationFrame(() => this.animate());
      }
    }

    destroy() {
      // Mark as destroyed to prevent timeout execution
      this.isDestroyed = true;
      
      // Cancel animation frame
      if (this.animationFrame !== null) {
        cancelAnimationFrame(this.animationFrame);
        this.animationFrame = null;
      }
      
      // Cancel idle timeout
      if (this.idleTimeout !== null) {
        clearTimeout(this.idleTimeout);
        this.idleTimeout = null;
      }
      
      // Remove event listeners
      const heroSection = document.querySelector('.hero-section');
      if (heroSection) {
        heroSection.removeEventListener('mousemove', this.mouseMoveHandler);
        heroSection.removeEventListener('mouseleave', this.mouseLeaveHandler);
      }
      
      this.elements = [];
    }
  }

  // Helper functions shared with laser overlay
  function randomEdgePoint(width, height, margin = 0) {
    const side = Math.floor(Math.random() * 4);
    switch (side) {
      case 0:
        return { x: -margin, y: Math.random() * height };
      case 1:
        return { x: width + margin, y: Math.random() * height };
      case 2:
        return { x: Math.random() * width, y: -margin };
      default:
        return { x: Math.random() * width, y: height + margin };
    }
  }

  function extendToBoundary(start, dir, width, height, margin = 0) {
    const candidates = [];
    if (Math.abs(dir.x) > 0.0001) {
      candidates.push({ t: (width + margin - start.x) / dir.x, x: width + margin, axis: 'x' });
      candidates.push({ t: (-margin - start.x) / dir.x, x: -margin, axis: 'x' });
    }
    if (Math.abs(dir.y) > 0.0001) {
      candidates.push({ t: (height + margin - start.y) / dir.y, y: height + margin, axis: 'y' });
      candidates.push({ t: (-margin - start.y) / dir.y, y: -margin, axis: 'y' });
    }
    const valid = candidates.filter((c) => c.t > 0);
    if (!valid.length) return { x: start.x, y: start.y };
    const best = valid.reduce((min, c) => (c.t < min.t ? c : min), valid[0]);
    if (best.axis === 'x') {
      const y = start.y + dir.y * best.t;
      return { x: best.x, y };
    }
    const x = start.x + dir.x * best.t;
    return { x, y: best.y };
  }

  function segmentCircleHit(a, b, circle) {
    const abx = b.x - a.x;
    const aby = b.y - a.y;
    const apx = circle.x - a.x;
    const apy = circle.y - a.y;
    const abLenSq = abx * abx + aby * aby || 1;
    let t = (apx * abx + apy * aby) / abLenSq;
    t = Math.max(0, Math.min(1, t));
    const closestX = a.x + abx * t;
    const closestY = a.y + aby * t;
    const dx = circle.x - closestX;
    const dy = circle.y - closestY;
    return dx * dx + dy * dy <= circle.r * circle.r;
  }

  // Laser overlay isolates drawing from bubble canvas
  class LaserOverlay {
    constructor() {
      this.canvas = null;
      this.ctx = null;
      this.dpr = 1;
      this.intervalId = null;
      this.fadeTimeout = null;
      this.clearTimeout = null;
      this.resizeHandler = () => this.resize();
      this.isVisible = true;
      this.visibilityHandler = null;
      this.audioContext = null;
      this.isOnScreen = true;
    }

    pause() {
      this.isOnScreen = false;
      // Stop any ongoing sounds by closing audio context
      if (this.audioContext && this.audioContext.state !== 'closed') {
        this.audioContext.close().catch(() => {});
        this.audioContext = null;
      }
    }

    resume() {
      this.isOnScreen = true;
    }

    playLaserSound() {
      // Don't play sound if hero is off screen
      if (!this.isOnScreen) return;
      
      try {
        // Create audio context if it doesn't exist
        if (!this.audioContext) {
          const AudioContext = window.AudioContext || window.webkitAudioContext;
          this.audioContext = new AudioContext();
        }

        // Resume audio context if suspended (required for autoplay policies)
        if (this.audioContext.state === 'suspended') {
          this.audioContext.resume();
        }

        // Create oscillator for high-pitched sound
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);

        const duration = 0.3; // Longer duration
        const startTime = this.audioContext.currentTime;
        
        // High-pitched frequency starts high and smoothly drops to lower pitch
        oscillator.frequency.setValueAtTime(3000, startTime);
        // Smooth pitch drop from start to end over the entire duration
        oscillator.frequency.exponentialRampToValueAtTime(1000, startTime + duration);

        // Volume envelope: quick attack, sustain, fade out
        gainNode.gain.setValueAtTime(0, startTime);
        gainNode.gain.linearRampToValueAtTime(0.15, startTime + 0.01); // Quick attack
        gainNode.gain.linearRampToValueAtTime(0.12, startTime + 0.1); // Slight decay
        gainNode.gain.setValueAtTime(0.12, startTime + 0.2); // Sustain
        gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + duration); // Fade out at end

        // Use a sine wave for a clean, high-pitched tone
        oscillator.type = 'sine';

        // Play the sound
        oscillator.start(startTime);
        oscillator.stop(startTime + duration);
      } catch (error) {
        // Silently fail if audio context can't be created (e.g., autoplay restrictions)
        console.debug('LaserOverlay: Could not play laser sound', error);
      }
    }

    init() {
      const canvas = document.getElementById('heroLaser');
      if (!(canvas instanceof HTMLCanvasElement)) return;
      this.canvas = canvas;
      const ctx = canvas.getContext('2d');
      if (!ctx) return;
      this.ctx = ctx;
      this.resize();
      window.addEventListener('resize', this.resizeHandler);
      
      // Handle visibility changes
      if (typeof document !== 'undefined') {
        this.visibilityHandler = () => {
          this.isVisible = !document.hidden;
        };
        document.addEventListener('visibilitychange', this.visibilityHandler);
      }
      
      this.intervalId = window.setInterval(() => {
        if (this.isVisible && this.isOnScreen) {
          this.fire();
        }
      }, LASER_INTERVAL_MS);
      setTimeout(() => {
        if (this.isVisible && this.isOnScreen) {
          this.fire();
        }
      }, LASER_INTERVAL_MS);
    }

    resize() {
      if (!this.canvas || !this.ctx) return;
      const width = this.canvas.clientWidth || window.innerWidth;
      const height = this.canvas.clientHeight || window.innerHeight;
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      this.dpr = dpr;
      this.canvas.width = Math.round(width * dpr);
      this.canvas.height = Math.round(height * dpr);
      this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    fire() {
      if (!this.canvas || !this.ctx) return;
      const width = this.canvas.width / this.dpr || this.canvas.clientWidth || window.innerWidth;
      const height = this.canvas.height / this.dpr || this.canvas.clientHeight || window.innerHeight;

      const soap = window?.soapBubbles_floatingShapesCanvas;
      const mainBubbles =
        soap?.shapes?.filter(
          (s) =>
            s &&
            !s.isPopping &&
            s.life === undefined &&
            Number.isFinite(s.radius) &&
            // Only consider bubbles fully on-screen
            s.x - s.radius >= 0 &&
            s.x + s.radius <= width &&
            s.y - s.radius >= 0 &&
            s.y + s.radius <= height
        ) || [];

      // If bubbles aren't ready yet, do nothing with laser
      // x //, still show a streak across the hero
      if (!mainBubbles.length) {
        // const startFallback = { x: 0, y: height * 0.5 };
        // const endFallback = { x: width, y: height * 0.5 };
        //   this.drawLaser(startFallback, endFallback);
        return;
      }

      // largest of top 6
      const ranked = [...mainBubbles]
        .filter((b) => b.x >= -b.radius && b.x <= width + b.radius && b.y >= -b.radius && b.y <= height + b.radius)
        .sort((a, b) => b.radius - a.radius)
        .slice(0, 6);
      const target = ranked[0];
      if (!target) return;

      const start = randomEdgePoint(width, height, 60);
      let dir = { x: target.x - start.x, y: target.y - start.y };
      if (Math.abs(dir.x) < 1) dir.x += (Math.random() > 0.5 ? 1 : -1) * 0.5;
      if (Math.abs(dir.y) < 1) dir.y += (Math.random() > 0.5 ? 1 : -1) * 0.5;
      const end = extendToBoundary(start, dir, width, height, 60);

      this.playLaserSound();
      this.drawLaser(start, end);
      this.popBubbles(mainBubbles, target, start, end);

      // Sets an expiration timestamp 1300ms in the future
      // Used to mark when the laser segment should no longer be considered active
      const expires = performance.now() + 1300;
      activeLaserSegment = { start, end, expires };
      // Also stores it on window so other components (like SoapBubbles) can access it
      // The SoapBubbles component checks window.activeLaserSegment in its physics loop (around line 718-787) to detect if bubbles intersect the laser path
      window.activeLaserSegment = activeLaserSegment;
      // After 1400ms, clears both references
      // 1400ms is slightly longer than the 1300ms expiration to ensure cleanup happens after the laser is no longer active
      setTimeout(() => {
        activeLaserSegment = null;
        window.activeLaserSegment = null;
      }, 1400);
    }

    drawLaser(start, end) {
      if (!this.ctx || !this.canvas) return;
      this.ctx.clearRect(0, 0, this.canvas.width / this.dpr, this.canvas.height / this.dpr);
      const gradient = this.ctx.createLinearGradient(start.x, start.y, end.x, end.y);
      gradient.addColorStop(0, 'rgba(255, 120, 120, 0.7)');
      gradient.addColorStop(0.5, 'rgba(255, 40, 40, 1)');
      gradient.addColorStop(1, 'rgba(255, 120, 120, 0.7)');
      this.ctx.strokeStyle = gradient;
      this.ctx.lineWidth = 2;
      this.ctx.shadowBlur = 6;
      this.ctx.shadowColor = 'rgba(255, 60, 60, 0.8)';
      this.ctx.beginPath();
      this.ctx.moveTo(start.x, start.y);
      this.ctx.lineTo(end.x, end.y);
      this.ctx.stroke();

      // Make the streak visible, then fade it out
      this.canvas.style.transition = 'none';
      this.canvas.style.opacity = '1';
      // force reflow so the next transition applies
      void this.canvas.offsetWidth;
      this.canvas.style.transition = 'opacity 0.8s ease-out'; // fade duration is 0.8 seconds
      if (this.fadeTimeout) clearTimeout(this.fadeTimeout);
      this.fadeTimeout = window.setTimeout(() => {
        this.canvas && (this.canvas.style.opacity = '0');
      }, 200); // fade starts after 200ms (laser visible for 200ms)
      if (this.clearTimeout) clearTimeout(this.clearTimeout);
      this.clearTimeout = window.setTimeout(() => {
        if (this.ctx && this.canvas) {
          this.ctx.clearRect(0, 0, this.canvas.width / this.dpr, this.canvas.height / this.dpr);
        }
      }, 1100); // canvas is cleared after 1100ms (200ms visible + 800ms fade + 100ms buffer)
    }

    popBubbles(mainBubbles, target, start, end) {
      const hitList = [];
      mainBubbles.forEach((b) => {
        const hit = segmentCircleHit(start, end, { x: b.x, y: b.y, r: b.radius || 0 });
        if (hit || b === target) {
          b.forcePop = true;
          hitList.push(b);
        }
      });
      if (hitList.length) {
        requestAnimationFrame(() => {
          try {
            hitList.forEach((b) => {
              window.dispatchEvent(
                new CustomEvent('soapbubbles:pop', {
                  detail: { id: b.id, x: b.x, y: b.y, radius: b.radius }
                })
              );
            });
          } catch (_) {}
        });
      }
    }

    destroy() {
      if (this.intervalId) {
        clearInterval(this.intervalId);
        this.intervalId = null;
      }
      if (this.fadeTimeout) {
        clearTimeout(this.fadeTimeout);
        this.fadeTimeout = null;
      }
      if (this.clearTimeout) {
        clearTimeout(this.clearTimeout);
        this.clearTimeout = null;
      }
      window.removeEventListener('resize', this.resizeHandler);
      
      if (this.visibilityHandler) {
        document.removeEventListener('visibilitychange', this.visibilityHandler);
        this.visibilityHandler = null;
      }
      
      if (this.ctx && this.canvas) {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      }
      activeLaserSegment = null;
      window.activeLaserSegment = null;
    }
  }

  // Particle Trail Effect
  class ParticleTrail {
    constructor() {
      this.canvas = null;
      this.ctx = null;
      this.trailPoints = [];
      this.pointer = { x: 0, y: 0, lastX: 0, lastY: 0, vx: 0, vy: 0, speed: 0, active: false };
      this.smoothedPointer = { x: 0, y: 0 };
      this.lastPointerUpdate = 0;
      this.lastEmitPosition = null;
      this.lastEmitTime = 0;
      this.emitInterval = 180;
      this.lastStationaryEmitTime = 0;
      this.stationaryEmitInterval = 800;
      this.stationaryThreshold = 500;
      this.lastFrameTime = 0;
      this.animationFrame = null;
      // Realistic max: ~22 particles/sec Ã— 4 sec lifetime = ~88 at max speed
      // Using 120 to provide headroom for stationary bubbles and edge cases
      this.initialMaxTrailPoints = 120;
      this.maxTrailPoints = this.initialMaxTrailPoints;
      this.performanceLimitedMax = null;
      this.minimumSpacing = 8;
      this.dpr = 1;
      this.disabled = false;
      this.currentPeakTrailCount = 0;
      this.performanceSamples = [];
      this.lastPerformanceCheck = 0;
      this.minBubbleCount = 30;
      this.dynamicBubbleCount = 30;
      this.populationDirty = false;
      this.isVisible = true;
      this.visibilityHandler = null;
      this.isOnScreen = true;

      if (typeof navigator !== 'undefined') {
        const deviceMemory = navigator.deviceMemory ?? 4;
        const cores = navigator.hardwareConcurrency ?? 0;
        
        // Apply optimizations based on device capabilities
        if (deviceMemory <= 2) {
          console.log("LOW MEMORY!");
          this.initialMaxTrailPoints = Math.min(this.initialMaxTrailPoints, 30);
          this.minimumSpacing = 10;
          this.emitInterval = Math.max(this.emitInterval, 220);
        }
        
        // Check CPU cores - apply additional optimizations if cores are limited
        if (cores > 0 && cores <= 4) {
          console.log("LOW CORES!");
          // Only reduce further if memory optimization didn't already set it lower
          if (this.initialMaxTrailPoints > 30) {
            this.initialMaxTrailPoints = Math.min(this.initialMaxTrailPoints, 40);
          }
          // Increase spacing and emission interval for low core systems
          this.minimumSpacing = Math.max(this.minimumSpacing, 9);
          this.emitInterval = Math.max(this.emitInterval, 200);
        }
      }
      this.maxTrailPoints = this.initialMaxTrailPoints;

      this.pointerMoveHandler = (e) => this.handlePointerMove(e);
      this.pointerLeaveHandler = () => this.handlePointerLeave();
      this.pointerDownHandler = () => this.handlePointerDown();
      this.pointerUpHandler = () => this.handlePointerUp();
      this.resizeHandler = () => this.resize();
    }

    init() {
      const canvasElement = document.getElementById('particleTrail');
      if (!(canvasElement instanceof HTMLCanvasElement)) return;
      this.canvas = canvasElement;

      const context = this.canvas.getContext('2d', { alpha: true });
      if (!context) return;
      this.ctx = context;

      const prefersReducedMotion = window.matchMedia ? window.matchMedia('(prefers-reduced-motion: reduce)').matches : false;
      const hasFinePointer = window.matchMedia ? window.matchMedia('(pointer: fine)').matches : true;
      if (prefersReducedMotion || !hasFinePointer) {
        this.disabled = true;
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        return;
      }

      this.resize();
      const heroSection = document.querySelector('.hero-section');
      if (heroSection) {
        if (window.PointerEvent) {
          heroSection.addEventListener('pointermove', this.pointerMoveHandler, { passive: true });
          heroSection.addEventListener('pointerdown', this.pointerDownHandler, { passive: true });
          heroSection.addEventListener('pointerup', this.pointerUpHandler, { passive: true });
          heroSection.addEventListener('pointerleave', this.pointerLeaveHandler);
        } else {
          heroSection.addEventListener('mousemove', this.pointerMoveHandler);
          heroSection.addEventListener('mousedown', this.pointerDownHandler);
          heroSection.addEventListener('mouseup', this.pointerUpHandler);
          heroSection.addEventListener('mouseleave', this.pointerLeaveHandler);
        }
      }
      window.addEventListener('resize', this.resizeHandler);
      
      // Handle visibility changes to pause/resume animations
      if (typeof document !== 'undefined') {
        this.visibilityHandler = () => {
          this.isVisible = !document.hidden;
        };
        document.addEventListener('visibilitychange', this.visibilityHandler);
      }
      
      this.animate();
    }

    resize() {
      if (!this.canvas || !this.ctx) return;

      const width = this.canvas.clientWidth || window.innerWidth;
      const height = this.canvas.clientHeight || window.innerHeight;
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      this.dpr = dpr;
      this.canvas.width = Math.round(width * dpr);
      this.canvas.height = Math.round(height * dpr);
      if (typeof this.ctx.setTransform === 'function') {
        this.ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      } else if (typeof this.ctx.resetTransform === 'function') {
        this.ctx.resetTransform();
        this.ctx.scale(dpr, dpr);
      } else {
        this.ctx.scale(dpr, dpr);
      }
      this.lastEmitPosition = null;
    }

    handlePointerDown() {
      this.pointer.active = true;
      this.lastPointerUpdate = performance.now();
    }

    handlePointerUp() {
      this.pointer.active = false;
    }

    handlePointerLeave() {
      this.pointer.active = false;
      this.lastEmitPosition = null;
      this.pointer.x = 0;
      this.pointer.y = 0;
      this.lastStationaryEmitTime = 0;
    }

    handlePointerMove(e) {
      if (!this.canvas) return;
      if (e.pointerType && e.pointerType !== 'mouse' && e.pointerType !== 'pen') {
        return;
      }

      const rect = this.canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      this.pointer.lastX = this.pointer.x;
      this.pointer.lastY = this.pointer.y;
      this.pointer.x = x;
      this.pointer.y = y;
      this.pointer.vx = this.pointer.x - (this.pointer.lastX ?? this.pointer.x);
      this.pointer.vy = this.pointer.y - (this.pointer.lastY ?? this.pointer.y);
      const speed = Math.sqrt(this.pointer.vx * this.pointer.vx + this.pointer.vy * this.pointer.vy);
      this.pointer.speed = speed;
      this.pointer.active = true;
      this.lastPointerUpdate = performance.now();

      if (!this.lastEmitPosition) {
        const spawn = this.getSpawnPosition(x, y);
        this.smoothedPointer.x = spawn.x;
        this.smoothedPointer.y = spawn.y;
        this.lastEmitPosition = { ...spawn };
        this.emitTrailPoint(spawn.x, spawn.y);
      }
    }

    getSpawnPosition(x, y) {
      if (!this.ctx) return;

      const soapBubbleColorSets = [
        ['rgba(255, 230, 250, 0.15)', 'rgba(230, 250, 255, 0.18)', 'rgba(240, 255, 255, 0.12)'],
        ['rgba(240, 230, 255, 0.16)', 'rgba(230, 240, 255, 0.17)', 'rgba(230, 255, 250, 0.14)'],
        ['rgba(230, 245, 255, 0.17)', 'rgba(240, 255, 255, 0.16)', 'rgba(255, 240, 250, 0.15)'],
        ['rgba(235, 255, 240, 0.15)', 'rgba(230, 245, 255, 0.17)', 'rgba(245, 235, 255, 0.16)'],
        ['rgba(255, 250, 235, 0.14)', 'rgba(255, 235, 245, 0.16)', 'rgba(235, 245, 255, 0.15)'],
        ['rgba(235, 255, 255, 0.16)', 'rgba(245, 235, 255, 0.15)', 'rgba(255, 235, 250, 0.17)']
      ];

      const pointerSpeed = Math.sqrt((this.pointer.vx || 0) ** 2 + (this.pointer.vy || 0) ** 2);
      const norm = pointerSpeed > 0.01 ? pointerSpeed : 1;
      const motionFactor = Math.min(pointerSpeed / 80, 1);
      const offsetDistance = 6 + motionFactor * 26;
      const offsetX = (this.pointer.vx || 0) / norm * offsetDistance;
      const offsetY = (this.pointer.vy || 0) / norm * offsetDistance;
      const driftAngle = Math.random() * Math.PI * 2;
      const driftMagnitude = 0.12 + motionFactor * 0.08;

      return {
        x: x - offsetX,
        y: y - offsetY,
        driftX: Math.cos(driftAngle) * driftMagnitude,
        driftY: Math.sin(driftAngle) * driftMagnitude,
        motionFactor,
        colors: soapBubbleColorSets[Math.floor(Math.random() * soapBubbleColorSets.length)]
      };
    }

    emitTrailPoint(x, y) {
      if (!this.ctx) return;
      if (this.trailPoints.length >= this.maxTrailPoints) return;

      const spawn = this.getSpawnPosition(x, y);
      if (!spawn) return;

      const angle = Math.random() * Math.PI * 2;
      const speed = 0.25 + Math.random() * 0.1;
      const velocityX = Math.cos(angle) * speed;
      const velocityY = Math.sin(angle) * speed;

      this.trailPoints.unshift({
        x: spawn.x + (Math.random() - 0.5) * 3,
        y: spawn.y + (Math.random() - 0.5) * 3,
        vx: velocityX,
        vy: velocityY,
        life: 1,
        birth: performance.now(),
        fullLifeMs: 4000,
        delayMs: 3000,
        shrinkStartMs: null,
        colors: spawn.colors,
        baseRadius: 3 + Math.random() * 3,
        currentRadius: 0,
        pulse: Math.random() * Math.PI * 2,
        pulseSpeed: 0.034 + Math.random() * 0.009
      });

      this.lastEmitTime = performance.now();
    }

    emitStationaryBubbles(x, y) {
      if (!this.ctx) return;
      if (this.trailPoints.length >= this.maxTrailPoints) return;

      const soapBubbleColorSets = [
        ['rgba(255, 230, 250, 0.15)', 'rgba(230, 250, 255, 0.18)', 'rgba(240, 255, 255, 0.12)'],
        ['rgba(240, 230, 255, 0.16)', 'rgba(230, 240, 255, 0.17)', 'rgba(230, 255, 250, 0.14)'],
        ['rgba(230, 245, 255, 0.17)', 'rgba(240, 255, 255, 0.16)', 'rgba(255, 240, 250, 0.15)'],
        ['rgba(235, 255, 240, 0.15)', 'rgba(230, 245, 255, 0.17)', 'rgba(245, 235, 255, 0.16)'],
        ['rgba(255, 250, 235, 0.14)', 'rgba(255, 235, 245, 0.16)', 'rgba(235, 245, 255, 0.15)'],
        ['rgba(235, 255, 255, 0.16)', 'rgba(245, 235, 255, 0.15)', 'rgba(255, 235, 250, 0.17)']
      ];

      // Emit 1-2 small bubbles moving away in different directions
      const bubbleCount = 1 + Math.floor(Math.random() * 2);
      
      for (let i = 0; i < bubbleCount; i++) {
        if (this.trailPoints.length >= this.maxTrailPoints) break;

        // Random angle for each bubble to move away from center
        const angle = Math.random() * Math.PI * 2;
        // Speed for stationary bubbles (doubled from original)
        const speed = 0.16 + Math.random() * 0.1;
        const velocityX = Math.cos(angle) * speed;
        const velocityY = Math.sin(angle) * speed;

        // Small random offset from exact pointer position
        const offsetX = (Math.random() - 0.5) * 8;
        const offsetY = (Math.random() - 0.5) * 8;

        this.trailPoints.unshift({
          x: x + offsetX,
          y: y + offsetY,
          vx: velocityX,
          vy: velocityY,
          life: 1,
          birth: performance.now(),
          fullLifeMs: 5000,
          delayMs: 3000,
          shrinkStartMs: null,
          colors: soapBubbleColorSets[Math.floor(Math.random() * soapBubbleColorSets.length)],
          baseRadius: 2 + Math.random() * 2, // Smaller bubbles
          currentRadius: 0,
          pulse: Math.random() * Math.PI * 2,
          pulseSpeed: 0.025 + Math.random() * 0.008
        });
      }

      this.lastStationaryEmitTime = performance.now();
    }

    pause() {
      this.isOnScreen = false;
    }

    resume() {
      this.isOnScreen = true;
    }

    animate() {
      if (!this.ctx || !this.canvas || this.disabled || !this.isOnScreen) return;

      const now = performance.now();
      this.lastFrameTime = now;
      
      // Safety check: limit trail points to prevent memory issues
      const maxTrailPointsHardLimit = 1000;
      if (this.trailPoints.length > maxTrailPointsHardLimit) {
        // Remove oldest points
        const excess = this.trailPoints.length - maxTrailPointsHardLimit;
        this.trailPoints.splice(-excess);
      }
      
      const timeSinceLastMove = now - this.lastPointerUpdate;
      const isStationary = timeSinceLastMove > this.stationaryThreshold && this.pointer.x > 0 && this.pointer.y > 0;
      
      if (this.pointer.active && timeSinceLastMove > 300) {
        this.pointer.active = false;
      }
      
      if (this.pointer.active || timeSinceLastMove < 250) {
        const followSpeed = this.pointer.active ? 0.34 : 0.1;
        this.smoothedPointer.x += (this.pointer.x - this.smoothedPointer.x) * followSpeed;
        this.smoothedPointer.y += (this.pointer.y - this.smoothedPointer.y) * followSpeed;

        const maxSpeed = 800;
        const minMultiplier = 1;
        const maxMultiplier = 4;
        const speedMultiplier = minMultiplier + Math.min(maxMultiplier - minMultiplier, (this.pointer.speed || 0) / maxSpeed * (maxMultiplier - minMultiplier));

        const current = { x: this.smoothedPointer.x, y: this.smoothedPointer.y };
        if (!this.lastEmitPosition) {
          this.lastEmitPosition = { ...current };
        }

        // const dx = current.x - this.lastEmitPosition.x;
        // const dy = current.y - this.lastEmitPosition.y;
        // const distance = Math.sqrt(dx * dx + dy * dy);

        // if (distance >= this.minimumSpacing) {
        //   const steps = Math.min(3, Math.floor(distance / this.minimumSpacing));
        //   for (let i = 1; i <= steps; i++) {
        //     if (this.trailPoints.length >= this.maxTrailPoints) break;
        //     const t = i / steps;
        //     const emitX = this.lastEmitPosition.x + dx * t;
        //     const emitY = this.lastEmitPosition.y + dy * t;
        //     this.emitTrailPoint(emitX, emitY);
        //     if (i === steps) {
        //       this.lastEmitPosition = { x: emitX, y: emitY };
        //     }
        //   }
        // } else 
        if (this.trailPoints.length < this.maxTrailPoints && (now - this.lastEmitTime) > this.emitInterval * speedMultiplier) {
          this.emitTrailPoint(current.x, current.y);
          this.lastEmitPosition = { ...current };
        } else {
          this.lastEmitPosition = { ...current };
        }
      } else {
        this.lastEmitPosition = null;
      }

      // Emit stationary bubbles when pointer is still in hero area but not moving
      if (isStationary && this.trailPoints.length < this.maxTrailPoints && (now - this.lastStationaryEmitTime) > this.stationaryEmitInterval) {
        this.emitStationaryBubbles(this.smoothedPointer.x, this.smoothedPointer.y);
      }

      const clearWidth = this.canvas.width / this.dpr;
      const clearHeight = this.canvas.height / this.dpr;
      
      // Only update and draw if visible (tab is active)
      if (this.isVisible) {
        this.ctx.clearRect(0, 0, clearWidth, clearHeight);
      }

      this.trailPoints = this.trailPoints.filter(point => {
        point.x += point.vx;
        point.y += point.vy;
        const elapsed = now - (point.birth || now);

        if (elapsed >= (point.fullLifeMs || 6000)) {
          return false;
        }

        let lifeFactor = 1;
        const delayMs = point.delayMs ?? 3000;
        const fadeWindow = Math.max((point.fullLifeMs || 6000) - delayMs, 1);

        if (elapsed >= delayMs) {
          if (point.shrinkStartMs === null) {
            point.shrinkStartMs = now;
          }
          const fadeElapsed = now - (point.shrinkStartMs || now);
          lifeFactor = Math.max(0, 1 - fadeElapsed / fadeWindow);
        }

        point.pulse += point.pulseSpeed;
        point.currentRadius = elapsed < delayMs ? point.baseRadius : point.baseRadius * lifeFactor;

        const alpha = elapsed < delayMs ? 1 : lifeFactor;

        // Only draw if visible (tab is active)
        if (!this.isVisible) {
          return true; // Keep point but don't draw
        }

        this.ctx.save();

        const bubblePath = new Path2D();
        const baseRadius = point.currentRadius;
        const pulseOffset = Math.sin(point.pulse) * 0.25;
        const pulseSize = Math.max(0.05, baseRadius + pulseOffset);
        bubblePath.arc(point.x, point.y, pulseSize, 0, Math.PI * 2);
        bubblePath.closePath();

        if (point.colors && point.colors.length >= 3) {
          const mainGradient = this.ctx.createRadialGradient(
            point.x - pulseSize * 0.35, point.y - pulseSize * 0.35, 0,
            point.x, point.y, pulseSize
          );
          mainGradient.addColorStop(0, `rgba(255, 255, 255, ${0.02 * alpha})`);
          mainGradient.addColorStop(0.7, this.adjustAlpha(point.colors[0], alpha));
          mainGradient.addColorStop(0.85, this.adjustAlpha(point.colors[1], alpha));
          mainGradient.addColorStop(1, this.adjustAlpha(point.colors[2], alpha));

          this.ctx.fillStyle = mainGradient;
          this.ctx.fill(bubblePath);
        }

        this.ctx.shadowBlur = 5;
        this.ctx.shadowColor = `rgba(255, 255, 255, ${0.35 * alpha})`;
        this.ctx.shadowOffsetX = 0;
        this.ctx.shadowOffsetY = 0;
        this.ctx.strokeStyle = `rgba(255, 255, 255, ${0.25 * alpha})`;
        this.ctx.lineWidth = 0.3;
        this.ctx.stroke(bubblePath);

      this.ctx.shadowBlur = 0;
      this.ctx.shadowColor = 'transparent';

      this.ctx.strokeStyle = `rgba(255, 255, 255, ${0.1 * alpha})`;
      this.ctx.lineWidth = 0.2;
      this.ctx.stroke(bubblePath);

      this.ctx.restore();
      return true;
    });

      if (this.trailPoints.length > this.currentPeakTrailCount) {
        this.currentPeakTrailCount = this.trailPoints.length;
      }

      this.ctx.globalAlpha = 1;
      
      try {
        this.animationFrame = requestAnimationFrame(() => this.animate());
      } catch (error) {
        console.error('ParticleTrail: Error in animation loop:', error);
        // Continue the loop even if there's an error
        this.animationFrame = requestAnimationFrame(() => this.animate());
      }

      if (now - this.lastPerformanceCheck >= 2000 && this.performanceSamples.length >= 20) {
        const avgFps = this.performanceSamples.reduce((sum, value) => sum + value, 0) / this.performanceSamples.length;
        const adaptiveTarget = this.calculateAdaptiveBubbleCount();

        if (avgFps < 42 && this.dynamicBubbleCount > this.minBubbleCount) {
          this.dynamicBubbleCount = Math.max(this.minBubbleCount, this.dynamicBubbleCount - 1);
          this.populationDirty = true;

          if (this.performanceLimitedMax === null) {
            this.performanceLimitedMax = Math.max(this.currentPeakTrailCount, this.trailPoints.length);
            this.maxTrailPoints = Math.min(this.maxTrailPoints, Math.floor(this.performanceLimitedMax * 0.75));
          }
        } else if (avgFps > 58 && this.dynamicBubbleCount < adaptiveTarget) {
          this.dynamicBubbleCount = Math.min(adaptiveTarget, this.dynamicBubbleCount + 1);
          this.populationDirty = true;
        }
 
        this.performanceSamples = [];
        this.lastPerformanceCheck = now;
      }
    }

    // Helper to adjust alpha in rgba color strings
    adjustAlpha(color, alpha) {
      // Match rgba values - format is rgba(r, g, b, a) where a is 0-1
      const match = color.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/);
      if (match) {
        const r = match[1];
        const g = match[2];
        const b = match[3];
        const originalAlpha = parseFloat(match[4]);
        return `rgba(${r}, ${g}, ${b}, ${originalAlpha * alpha})`;
      }
      return color;
    }

    destroy() {
      if (this.animationFrame !== null) {
        cancelAnimationFrame(this.animationFrame);
        this.animationFrame = null;
      }
      const heroSection = document.querySelector('.hero-section');
      if (heroSection) {
        heroSection.removeEventListener('pointermove', this.pointerMoveHandler);
        heroSection.removeEventListener('pointerdown', this.pointerDownHandler);
        heroSection.removeEventListener('pointerup', this.pointerUpHandler);
        heroSection.removeEventListener('pointerleave', this.pointerLeaveHandler);
        heroSection.removeEventListener('mousemove', this.pointerMoveHandler);
        heroSection.removeEventListener('mousedown', this.pointerDownHandler);
        heroSection.removeEventListener('mouseup', this.pointerUpHandler);
        heroSection.removeEventListener('mouseleave', this.pointerLeaveHandler);
      }
      window.removeEventListener('resize', this.resizeHandler);
      
      if (this.visibilityHandler) {
        document.removeEventListener('visibilitychange', this.visibilityHandler);
        this.visibilityHandler = null;
      }
      
      this.trailPoints = [];
      if (this.ctx && this.canvas) {
        const clearWidth = this.canvas.width / this.dpr;
        const clearHeight = this.canvas.height / this.dpr;
        this.ctx.clearRect(0, 0, clearWidth, clearHeight);
      }
    }
  }

  // Shared laser segment state so other systems can react
  let activeLaserSegment = null;
  const LASER_INTERVAL_MS = 10000; // every 10 seconds

  // Initialize effects
  let magneticText = null;
  let particleTrail = null;
  let laserOverlay = null;

  document.addEventListener('DOMContentLoaded', () => {
    magneticText = new MagneticText();
    magneticText.init();

    particleTrail = new ParticleTrail();
    particleTrail.init();

    laserOverlay = new LaserOverlay();
    laserOverlay.init();

    // Set up Intersection Observer to pause animations when hero is off screen
    const heroSection = document.querySelector('.hero-section');
    if (heroSection && 'IntersectionObserver' in window) {
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          const isOnScreen = entry.isIntersecting;
          
          // Pause/resume all animations
          if (magneticText) {
            if (isOnScreen) {
              magneticText.resume();
            } else {
              magneticText.pause();
            }
          }
          
          if (particleTrail) {
            if (isOnScreen) {
              particleTrail.resume();
            } else {
              particleTrail.pause();
            }
          }
          
          if (laserOverlay) {
            if (isOnScreen) {
              laserOverlay.resume();
            } else {
              laserOverlay.pause();
            }
          }
          
          // Pause/resume bubble animations
          const soapBubbles = window?.soapBubbles_floatingShapesCanvas;
          if (soapBubbles && typeof soapBubbles.pause === 'function' && typeof soapBubbles.resume === 'function') {
            if (isOnScreen) {
              soapBubbles.resume();
            } else {
              soapBubbles.pause();
            }
          }
        });
      }, {
        threshold: 0.1 // Trigger when at least 10% of hero section is visible
      });
      
      observer.observe(heroSection);
    }

    // Trigger initial jiggle sequence on page load
    setTimeout(() => {
      if (magneticText) {
        magneticText.triggerGlowSequence(true); // force = true to bypass isActive check
      }
    }, 500); // Small delay to ensure page is fully loaded
  });

  // Cleanup on page unload
  window.addEventListener('beforeunload', () => {
    if (magneticText) {
      magneticText.destroy();
      magneticText = null;
    }
    if (particleTrail) {
      particleTrail.destroy();
      particleTrail = null;
    }
    if (laserOverlay) {
      laserOverlay.destroy();
      laserOverlay = null;
    }
  });
</script>

<style>
  /* Hero button styling */
  .hero-button {
    position: relative;
    z-index: 50;
    will-change: transform;
  }

  /* Content wrapper - isolates text from background blobs */
  .content-wrapper::before {
    content: '';
    position: absolute;
    inset: -50px;
    background: radial-gradient(ellipse at center, rgba(0, 0, 0, 0.2) 0%, transparent 70%);
    backdrop-filter: blur(1px);
    z-index: -1;
    pointer-events: none;
  }

  /* Magnetic text styling */
  .magnetic-text {
    display: inline-block;
    transition: transform 0.1s ease-out;
    will-change: transform;
    transform-style: preserve-3d;
    color: #7661d1 !important;
    filter: drop-shadow(2px 2px 4px rgba(0, 0, 0, 0.6)) drop-shadow(0 0 8px rgba(118, 97, 209, 0.4));
    -webkit-text-stroke: 1px rgba(255, 255, 255, 0.1);
  }
  
  /* Smooth transition only when actively transforming */
  .magnetic-text[style*="rotate"] {
    transition: transform 0.08s ease-out;
  }

  /* Word styling */
  .word {
    display: inline-block;
    transition: text-shadow 0.5s ease-in-out;
  }

  /* Jiggle animation for words */
  .word.jiggle {
    animation: jiggle 0.3s ease-in-out;
  }

  @keyframes jiggle {
    0%, 100% {
      transform: translateX(0) translateY(0) rotate(0deg);
    }
    10% {
      transform: translateX(-2px) translateY(-1px) rotate(-1deg);
    }
    20% {
      transform: translateX(2px) translateY(1px) rotate(1deg);
    }
    30% {
      transform: translateX(-1px) translateY(1px) rotate(-0.5deg);
    }
    40% {
      transform: translateX(1px) translateY(-1px) rotate(0.5deg);
    }
    50% {
      transform: translateX(-1px) translateY(-1px) rotate(-0.5deg);
    }
    60% {
      transform: translateX(1px) translateY(1px) rotate(0.5deg);
    }
    70% {
      transform: translateX(-1px) translateY(0px) rotate(-0.3deg);
    }
    80% {
      transform: translateX(1px) translateY(0px) rotate(0.3deg);
    }
    90% {
      transform: translateX(0px) translateY(0px) rotate(0deg);
    }
  }

  /* Liquid blob animations */
  .liquid-blobs {
    filter: blur(40px);
    opacity: 0.9;
    z-index: 1;
  }

  .blob {
    position: absolute;
    border-radius: 50%;
    will-change: transform;
    z-index: 1;
  }

  .blob-1 {
    width: 800px;
    height: 800px;
    background: radial-gradient(circle, rgba(147, 51, 234, 0.95), rgba(79, 70, 229, 0.85));
    top: 5%;
    left: 0%;
    animation: blobFloat1 20s ease-in-out infinite;
  }

  .blob-2 {
    width: 900px;
    height: 900px;
    background: radial-gradient(circle, rgba(79, 70, 229, 0.95), rgba(59, 130, 246, 0.85));
    bottom: 5%;
    right: 0%;
    animation: blobFloat2 25s ease-in-out infinite;
  }

  .blob-3 {
    width: 700px;
    height: 700px;
    background: radial-gradient(circle, rgba(59, 130, 246, 0.9), rgba(37, 99, 235, 0.75));
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    animation: blobFloat3 30s ease-in-out infinite;
  }

  @keyframes blobFloat1 {
    0%, 100% { transform: translate(0, 0) scale(1) rotate(0deg); }
    33% { transform: translate(120px, 80px) scale(1.2) rotate(120deg); }
    66% { transform: translate(-60px, 100px) scale(0.9) rotate(240deg); }
  }

  @keyframes blobFloat2 {
    0%, 100% { transform: translate(0, 0) scale(1) rotate(0deg); }
    33% { transform: translate(-100px, -120px) scale(1.3) rotate(120deg); }
    66% { transform: translate(120px, -60px) scale(0.85) rotate(240deg); }
  }

  @keyframes blobFloat3 {
    0%, 100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
    33% { transform: translate(-45%, -60%) scale(1.3) rotate(120deg); }
    66% { transform: translate(-55%, -40%) scale(0.8) rotate(240deg); }
  }

  /* Floating shapes canvas - behind particles but above background */
  #floatingShapesCanvas {
    z-index: 4;
  }

  /* Particle canvas - on top so particles are visible */
  #particleTrail {
    z-index: 5;
  }

  .content-wrapper {
    user-select: none;
    -webkit-user-select: none;
    -ms-user-select: none;
  }

  .content-wrapper * {
    user-select: none;
    -webkit-user-select: none;
    -ms-user-select: none;
    cursor: default;
  }
</style>
