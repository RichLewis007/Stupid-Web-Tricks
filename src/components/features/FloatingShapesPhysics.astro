---
// FloatingShapesPhysics.astro - Interactive floating shapes with physics
---

<div class="floating-shapes-container">
  <!-- Floating geometric shapes -->
  <div class="floating-shape shape-1"></div>
  <div class="floating-shape shape-2"></div>
  <div class="floating-shape shape-3"></div>
  <div class="floating-shape shape-4"></div>
  <div class="floating-shape shape-5"></div>
  <div class="floating-shape shape-6"></div>
</div>

<script>
  // Floating Shapes Physics System
  class FloatingShapesPhysics {
    shapes: any[];
    isRunning: boolean;

    constructor() {
      this.shapes = [];
      this.isRunning = false;
      this.init();
    }

    init() {
      // Initialize existing shapes
      this.initializeShapes();
      // Start the physics loop
      this.startPhysics();
    }

    initializeShapes() {
      const existingShapes = document.querySelectorAll('.floating-shape');
      existingShapes.forEach((shape, index) => {
        const rect = shape.getBoundingClientRect();
        this.shapes.push({
          element: shape,
          x: rect.left,
          y: rect.top,
          vx: (Math.random() - 0.5) * 2, // Random velocity -1 to 1 px/frame
          vy: (Math.random() - 0.5) * 2,
          radius: rect.width / 2,
          mass: rect.width / 2 // Mass proportional to size
        });
      });
    }

    startPhysics() {
      if (this.isRunning) return;
      this.isRunning = true;
      this.physicsLoop();
    }

    physicsLoop() {
      if (!this.isRunning) return;
      
      this.updatePhysics();
      requestAnimationFrame(() => this.physicsLoop());
    }

    updatePhysics() {
      const screenWidth = window.innerWidth;
      const screenHeight = window.innerHeight;

      this.shapes.forEach((shape, index) => {
        // Update position
        shape.x += shape.vx;
        shape.y += shape.vy;

        // Screen edge collisions
        if (shape.x - shape.radius <= 0) {
          shape.x = shape.radius;
          shape.vx = Math.abs(shape.vx); // Bounce right
        }
        if (shape.x + shape.radius >= screenWidth) {
          shape.x = screenWidth - shape.radius;
          shape.vx = -Math.abs(shape.vx); // Bounce left
        }
        if (shape.y - shape.radius <= 0) {
          shape.y = shape.radius;
          shape.vy = Math.abs(shape.vy); // Bounce down
        }
        if (shape.y + shape.radius >= screenHeight) {
          shape.y = screenHeight - shape.radius;
          shape.vy = -Math.abs(shape.vy); // Bounce up
        }

        // Shape-to-shape collisions
        for (let otherIndex = index + 1; otherIndex < this.shapes.length; otherIndex++) {
          const otherShape = this.shapes[otherIndex];
          const dx = shape.x - otherShape.x;
          const dy = shape.y - otherShape.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const minDistance = shape.radius + otherShape.radius;

          if (distance < minDistance && distance > 0) {
            // Collision detected - calculate collision response
            const overlap = minDistance - distance;
            const separationX = (dx / distance) * overlap * 0.5;
            const separationY = (dy / distance) * overlap * 0.5;

            // Separate shapes
            shape.x += separationX;
            shape.y += separationY;
            otherShape.x -= separationX;
            otherShape.y -= separationY;

            // Calculate new velocities (elastic collision)
            const relativeVelocityX = shape.vx - otherShape.vx;
            const relativeVelocityY = shape.vy - otherShape.vy;
            const relativeVelocityDotProduct = relativeVelocityX * dx + relativeVelocityY * dy;
            const impulse = (2 * relativeVelocityDotProduct) / (shape.mass + otherShape.mass) / distance;

            shape.vx -= impulse * otherShape.mass * dx / distance;
            shape.vy -= impulse * otherShape.mass * dy / distance;
            otherShape.vx += impulse * shape.mass * dx / distance;
            otherShape.vy += impulse * shape.mass * dy / distance;
          }
        }

        // Apply position to DOM element
        shape.element.style.left = shape.x - shape.radius + 'px';
        shape.element.style.top = shape.y - shape.radius + 'px';
      });
    }

    addShape(element: HTMLElement) {
      const rect = element.getBoundingClientRect();
      // Convert viewport coordinates to document coordinates
      const x = rect.left + window.scrollX + rect.width / 2;
      const y = rect.top + window.scrollY + rect.height / 2;
      
      this.shapes.push({
        element: element,
        x: x,
        y: y,
        vx: (Math.random() - 0.5) * 0.5, // Give it gentle movement immediately
        vy: (Math.random() - 0.5) * 0.5,
        radius: rect.width / 2,
        mass: rect.width / 2
      });
    }

    removeShape(element: HTMLElement) {
      this.shapes = this.shapes.filter(shape => shape.element !== element);
    }
  }

  // Initialize floating shapes physics when DOM is loaded
  document.addEventListener('DOMContentLoaded', function() {
    // Initialize floating shapes physics system
    const floatingShapesPhysics = new FloatingShapesPhysics();
    (window as any).floatingShapesPhysics = floatingShapesPhysics;

    // Add interactive hover and click effects to floating shapes
    document.querySelectorAll('.floating-shape').forEach((shape, index) => {
      const shapeElement = shape as HTMLElement;
      console.log(`Setting up shape ${index + 1}`);
      
      // Give each shape a random iridescent bubble color
      const iridescentColors = [
        'linear-gradient(45deg, rgba(255, 0, 150, 0.7), rgba(0, 255, 255, 0.7), rgba(255, 255, 0, 0.7))',
        'linear-gradient(45deg, rgba(255, 100, 200, 0.7), rgba(100, 255, 100, 0.7), rgba(200, 100, 255, 0.7))',
        'linear-gradient(45deg, rgba(0, 200, 255, 0.7), rgba(255, 200, 0, 0.7), rgba(200, 0, 255, 0.7))',
        'linear-gradient(45deg, rgba(255, 150, 0, 0.7), rgba(0, 150, 255, 0.7), rgba(150, 0, 255, 0.7))',
        'linear-gradient(45deg, rgba(200, 255, 0, 0.7), rgba(255, 0, 200, 0.7), rgba(0, 200, 255, 0.7))',
        'linear-gradient(45deg, rgba(255, 0, 255, 0.7), rgba(0, 255, 150, 0.7), rgba(255, 150, 0, 0.7))',
        'linear-gradient(45deg, rgba(150, 0, 255, 0.7), rgba(255, 255, 0, 0.7), rgba(0, 255, 200, 0.7))',
        'linear-gradient(45deg, rgba(0, 255, 255, 0.7), rgba(255, 0, 150, 0.7), rgba(255, 200, 0, 0.7))'
      ];
      
      const randomColor = iridescentColors[Math.floor(Math.random() * iridescentColors.length)];
      shapeElement.style.background = randomColor;
      shapeElement.style.boxShadow = '0 0 20px rgba(255, 255, 255, 0.3), inset 0 0 20px rgba(255, 255, 255, 0.1)';
      
      shapeElement.addEventListener('mouseenter', () => {
        shapeElement.style.transform = 'scale(1.2) rotate(180deg)';
        shapeElement.style.transition = 'transform 0.3s ease';
      });
      
      shapeElement.addEventListener('mouseleave', () => {
        shapeElement.style.transform = '';
        shapeElement.style.transition = 'transform 0.3s ease';
      });

      // Add click handler for pop animation
      shapeElement.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation(); // Prevent click from reaching constellation system
        console.log('Shape clicked!');
        
        // Create pop animation
        shapeElement.style.transform = 'scale(2) rotate(360deg)';
        shapeElement.style.opacity = '0';
        shapeElement.style.transition = 'all 0.4s ease-out';
        
        // Create explosion effect
        createExplosionEffect(shapeElement);
        
        // Remove the clicked shape after animation
        setTimeout(() => {
          // Remove from physics system first
          floatingShapesPhysics.removeShape(shapeElement);
          shapeElement.remove();
          
          // Create a new random circle
          createNewFloatingShape();
        }, 400);
      });
    });

    // Function to create explosion effect
    function createExplosionEffect(element: HTMLElement) {
      const rect = element.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      
      // Create explosion particles
      for (let i = 0; i < 12; i++) {
        const particle = document.createElement('div');
        particle.style.position = 'fixed';
        particle.style.left = centerX + 'px';
        particle.style.top = centerY + 'px';
        particle.style.width = '6px';
        particle.style.height = '6px';
        particle.style.borderRadius = '50%';
        particle.style.backgroundColor = `hsl(${Math.random() * 360}, 70%, 60%)`;
        particle.style.pointerEvents = 'none';
        particle.style.zIndex = '1000';
        particle.style.transform = 'translate(-50%, -50%)';
        
        document.body.appendChild(particle);
        
        // Animate particle
        const angle = (i / 12) * Math.PI * 2;
        const distance = 60 + Math.random() * 40;
        const endX = centerX + Math.cos(angle) * distance;
        const endY = centerY + Math.sin(angle) * distance;
        
        particle.animate([
          { 
            transform: 'translate(-50%, -50%) scale(1)',
            opacity: 1
          },
          { 
            transform: `translate(${endX - centerX - 3}px, ${endY - centerY - 3}px) scale(0)`,
            opacity: 0
          }
        ], {
          duration: 800,
          easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
        }).onfinish = () => {
          particle.remove();
        };
      }
    }

    // Function to create a new floating shape
    function createNewFloatingShape() {
      // Find the container that actually contains the floating shapes
      const existingShapes = document.querySelectorAll('.floating-shape');
      let container = null;
      
      if (existingShapes.length > 0) {
        container = existingShapes[0].parentElement;
      } else {
        container = document.querySelector('.floating-shapes-container');
      }
      
      if (!container) {
        console.error('Container not found');
        return;
      }
      
      const newShape = document.createElement('div');
      newShape.className = 'floating-shape';
      
      // Random properties
      const finalSize = Math.random() * 60 + 40; // 40-100px final size
      const startSize = 5; // Start very tiny
      const iridescentColors = [
        'linear-gradient(45deg, rgba(255, 0, 150, 0.7), rgba(0, 255, 255, 0.7), rgba(255, 255, 0, 0.7))',
        'linear-gradient(45deg, rgba(255, 100, 200, 0.7), rgba(100, 255, 100, 0.7), rgba(200, 100, 255, 0.7))',
        'linear-gradient(45deg, rgba(0, 200, 255, 0.7), rgba(255, 200, 0, 0.7), rgba(200, 0, 255, 0.7))',
        'linear-gradient(45deg, rgba(255, 150, 0, 0.7), rgba(0, 150, 255, 0.7), rgba(150, 0, 255, 0.7))',
        'linear-gradient(45deg, rgba(200, 255, 0, 0.7), rgba(255, 0, 200, 0.7), rgba(0, 200, 255, 0.7))',
        'linear-gradient(45deg, rgba(255, 0, 255, 0.7), rgba(0, 255, 150, 0.7), rgba(255, 150, 0, 0.7))',
        'linear-gradient(45deg, rgba(150, 0, 255, 0.7), rgba(255, 255, 0, 0.7), rgba(0, 255, 200, 0.7))',
        'linear-gradient(45deg, rgba(0, 255, 255, 0.7), rgba(255, 0, 150, 0.7), rgba(255, 200, 0, 0.7))'
      ];
      
      // Random position within viewport
      const spawnX = Math.random() * (window.innerWidth - finalSize);
      const spawnY = Math.random() * (window.innerHeight - finalSize);
      
      // Apply all styles explicitly to ensure they work
      newShape.style.position = 'absolute';
      newShape.style.width = finalSize + 'px'; // Set final size immediately
      newShape.style.height = finalSize + 'px'; // Set final size immediately
      newShape.style.borderRadius = '50%';
      newShape.style.background = iridescentColors[Math.floor(Math.random() * iridescentColors.length)];
      newShape.style.boxShadow = '0 0 20px rgba(255, 255, 255, 0.3), inset 0 0 20px rgba(255, 255, 255, 0.1)';
      newShape.style.top = spawnY + 'px';
      newShape.style.left = spawnX + 'px';
      newShape.style.transform = 'scale(0.1)'; // Start tiny (10% of final size)
      newShape.style.animationDelay = Math.random() * 8 + 's';
      newShape.style.cursor = 'pointer';
      newShape.style.zIndex = '20';
      newShape.style.pointerEvents = 'auto';
      newShape.style.opacity = '0.9';
      newShape.style.backdropFilter = 'blur(10px)';
      newShape.style.border = '2px solid rgba(255, 255, 255, 0.3)';
      newShape.style.transition = 'all 0.3s ease-out'; // Smooth expansion
      
      // Add event listeners
      newShape.addEventListener('mouseenter', () => {
        newShape.style.transform = 'scale(1.2) rotate(180deg)';
        newShape.style.transition = 'transform 0.3s ease';
      });
      
      newShape.addEventListener('mouseleave', () => {
        newShape.style.transform = '';
        newShape.style.transition = 'transform 0.3s ease';
      });

      newShape.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation(); // Prevent click from reaching constellation system
        
        // Create pop animation
        newShape.style.transform = 'scale(2) rotate(360deg)';
        newShape.style.opacity = '0';
        newShape.style.transition = 'all 0.4s ease-out';
        
        // Create explosion effect
        createExplosionEffect(newShape);
        
        // Remove the clicked shape after animation
        setTimeout(() => {
          // Remove from physics system first
          floatingShapesPhysics.removeShape(newShape);
          newShape.remove();
          
          // Create a new random circle
          createNewFloatingShape();
        }, 400);
      });
      
      // Insert into container
      container.appendChild(newShape);
      
      // Set final size immediately but scale from center
      newShape.style.width = finalSize + 'px';
      newShape.style.height = finalSize + 'px';
      newShape.style.transform = 'scale(0.1)'; // Start tiny (10% of final size)
      
      // Add entrance animation - expand from center using scale
      setTimeout(() => {
        newShape.style.transition = 'transform 0.3s ease-out';
        newShape.style.transform = 'scale(1)'; // Expand to full size
        
        // Add gentle CSS animation instead of physics
        setTimeout(() => {
          newShape.style.animation = 'gentle-drift 8s ease-in-out infinite';
        }, 300); // After expansion completes
      }, 50); // Small delay to ensure DOM is ready
    }
  });
</script>

<style>
  .floating-shapes-container {
    position: absolute;
    inset: 0;
    pointer-events: none;
  }

  .floating-shape {
    position: absolute !important;
    border-radius: 50%;
    background: linear-gradient(45deg, rgba(102, 126, 234, 0.6), rgba(118, 75, 162, 0.6));
    backdrop-filter: blur(10px);
    border: 2px solid rgba(255, 255, 255, 0.3);
    cursor: pointer;
    z-index: 20 !important;
    opacity: 0.9;
    pointer-events: auto !important;
  }

  @keyframes gentle-drift {
    0%, 100% { transform: translate(0, 0); }
    25% { transform: translate(10px, -5px); }
    50% { transform: translate(-5px, 10px); }
    75% { transform: translate(-10px, -5px); }
  }
  
  .shape-1 {
    width: 80px;
    height: 80px;
    top: 10%;
    left: 10%;
    animation-delay: 0s;
    background: linear-gradient(45deg, rgba(255, 0, 150, 0.6), rgba(0, 255, 255, 0.6));
  }
  
  .shape-2 {
    width: 120px;
    height: 120px;
    top: 20%;
    right: 15%;
    animation-delay: 2s;
    background: linear-gradient(45deg, rgba(255, 255, 0, 0.6), rgba(255, 0, 255, 0.6));
  }
  
  .shape-3 {
    width: 60px;
    height: 60px;
    bottom: 20%;
    left: 20%;
    animation-delay: 4s;
    background: linear-gradient(45deg, rgba(0, 255, 150, 0.6), rgba(150, 0, 255, 0.6));
  }
  
  .shape-4 {
    width: 100px;
    height: 100px;
    bottom: 30%;
    right: 25%;
    animation-delay: 1s;
    background: linear-gradient(45deg, rgba(255, 100, 0, 0.6), rgba(0, 100, 255, 0.6));
  }
  
  .shape-5 {
    width: 40px;
    height: 40px;
    top: 50%;
    left: 5%;
    animation-delay: 3s;
    background: linear-gradient(45deg, rgba(255, 255, 255, 0.6), rgba(0, 0, 0, 0.6));
  }
  
  .shape-6 {
    width: 90px;
    height: 90px;
    top: 60%;
    right: 10%;
    animation-delay: 5s;
    background: linear-gradient(45deg, rgba(150, 255, 0, 0.6), rgba(255, 0, 150, 0.6));
  }
</style>
