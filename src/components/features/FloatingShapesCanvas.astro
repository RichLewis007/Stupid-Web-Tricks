---
// FloatingShapesCanvas.astro - Canvas-based floating shapes with physics
---

<canvas id="floatingShapesCanvas" class="absolute inset-0 w-full h-full pointer-events-none"></canvas>

<script>
  // TypeScript interfaces
  interface FloatingShape {
    x: number;
    y: number;
    vx: number;
    vy: number;
    radius: number;
    mass: number;
    color: string;
    colors?: string[]; // Array of gradient colors for iridescent effect
    originalColor: string;
    hoverColor: string;
    isHovered: boolean;
    pulse: number;
    pulseSpeed: number;
    id: number;
    life?: number;
    size?: number;
    wobblePhase?: number; // For wobbly edge animation
    wobbleSpeed?: number; // Speed of wobble animation
    distortionSeed?: number; // Random seed for shape distortion
    reflectionAngle?: number; // Angle for reflection highlight
    isPopping?: boolean; // Track if bubble is in pop animation
    popPhase?: number; // Pop animation phase (0-1)
  }

  interface MousePosition {
    x: number;
    y: number;
  }

  // Canvas-based Floating Shapes Physics System
  class FloatingShapesCanvas {
    canvas: HTMLCanvasElement;
    ctx: CanvasRenderingContext2D;
    shapes: FloatingShape[];
    isRunning: boolean;
    mouse: MousePosition;
    animationFrameId: number | null = null;
    resizeHandler: () => void;
    mouseMoveHandler: (e: MouseEvent) => void;
    clickHandler: (e: MouseEvent) => void;
    initialized: boolean = false;
    pendingTimeouts: number[] = []; // Track setTimeout IDs for cleanup
    isDestroyed: boolean = false; // Flag to prevent operations after destroy

    constructor() {
      this.canvas = document.getElementById('floatingShapesCanvas') as HTMLCanvasElement;
      if (!this.canvas) {
        console.warn('FloatingShapesCanvas: Canvas element not found');
        return;
      }
      
      const ctx = this.canvas.getContext('2d');
      if (!ctx) {
        console.warn('FloatingShapesCanvas: Could not get 2D context');
        return;
      }
      
      this.ctx = ctx;
      this.shapes = [];
      this.isRunning = false;
      this.mouse = { x: 0, y: 0 };
      
      // Bind handlers to preserve context
      this.resizeHandler = () => this.resizeCanvas();
      this.mouseMoveHandler = (e: MouseEvent) => this.handleMouseMove(e);
      this.clickHandler = (e: MouseEvent) => this.handleClick(e);
      
      this.initialized = true;
      this.init();
      console.log('FloatingShapesCanvas: Initialized with', this.shapes.length, 'shapes. Canvas size:', this.canvas.width, 'x', this.canvas.height);
    }

    init() {
      this.resizeCanvas();
      this.createShapes();
      this.bindEvents();
      this.startPhysics();
    }

    resizeCanvas() {
      const heroSection = document.querySelector('.hero-section');
      if (heroSection) {
        const rect = heroSection.getBoundingClientRect();
        this.canvas.width = rect.width;
        this.canvas.height = rect.height;
      } else {
        // Fallback to window size
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
      }
      console.log('FloatingShapesCanvas: Resized to', this.canvas.width, 'x', this.canvas.height);
    }

    createShapes() {
      // Ensure canvas is sized
      if (this.canvas.width === 0 || this.canvas.height === 0) {
        this.resizeCanvas();
      }
      
      // Create 6 floating bubbles with realistic soap bubble colors (pale, iridescent)
      const soapBubbleColors = [
        // Shape 1: 80px - pale pink/blue/cyan (very subtle)
        ['rgba(255, 230, 250, 0.15)', 'rgba(230, 250, 255, 0.18)', 'rgba(240, 255, 255, 0.12)'],
        // Shape 2: 120px - pale purple/blue/green
        ['rgba(240, 230, 255, 0.16)', 'rgba(230, 240, 255, 0.17)', 'rgba(230, 255, 250, 0.14)'],
        // Shape 3: 60px - pale blue/cyan/pink
        ['rgba(230, 245, 255, 0.17)', 'rgba(240, 255, 255, 0.16)', 'rgba(255, 240, 250, 0.15)'],
        // Shape 4: 100px - pale green/blue/purple
        ['rgba(235, 255, 240, 0.15)', 'rgba(230, 245, 255, 0.17)', 'rgba(245, 235, 255, 0.16)'],
        // Shape 5: 40px - pale yellow/pink/blue
        ['rgba(255, 250, 235, 0.14)', 'rgba(255, 235, 245, 0.16)', 'rgba(235, 245, 255, 0.15)'],
        // Shape 6: 90px - pale cyan/purple/pink
        ['rgba(235, 255, 255, 0.16)', 'rgba(245, 235, 255, 0.15)', 'rgba(255, 235, 250, 0.17)']
      ];

      const shapeConfigs = [
        { size: 80, colors: soapBubbleColors[0] },
        { size: 120, colors: soapBubbleColors[1] },
        { size: 60, colors: soapBubbleColors[2] },
        { size: 100, colors: soapBubbleColors[3] },
        { size: 40, colors: soapBubbleColors[4] },
        { size: 90, colors: soapBubbleColors[5] }
      ];

      this.shapes = shapeConfigs.map((config, index) => {
        const radius = config.size / 2;
        
        // Find a safe position away from text and button
        let x: number, y: number;
        let attempts = 0;
        const maxAttempts = 50;
        
        do {
          x = Math.random() * this.canvas.width;
          y = Math.random() * this.canvas.height;
          attempts++;
        } while (!this.isPositionSafe(x, y, radius) && attempts < maxAttempts);
        
        // If we couldn't find a safe position, place at edges
        if (attempts >= maxAttempts) {
          const corner = Math.floor(Math.random() * 4);
          switch (corner) {
            case 0: // Top-left
              x = radius + 20;
              y = radius + 20;
              break;
            case 1: // Top-right
              x = this.canvas.width - radius - 20;
              y = radius + 20;
              break;
            case 2: // Bottom-left
              x = radius + 20;
              y = this.canvas.height - radius - 20;
              break;
            case 3: // Bottom-right
              x = this.canvas.width - radius - 20;
              y = this.canvas.height - radius - 20;
              break;
          }
        }
        
        return {
          x: x,
          y: y,
          vx: (Math.random() - 0.5) * 2,
          vy: (Math.random() - 0.5) * 2,
          radius: radius,
          mass: radius,
          color: config.colors[0], // Primary color for explosion particles
          colors: config.colors, // Array of gradient colors
          originalColor: config.colors[0],
          hoverColor: this.lightenColor(config.colors[0], 0.3),
          isHovered: false,
          pulse: Math.random() * Math.PI * 2,
          pulseSpeed: Math.random() * 0.02 + 0.01,
          id: index,
          wobblePhase: Math.random() * Math.PI * 2,
          wobbleSpeed: Math.random() * 0.03 + 0.02,
          distortionSeed: Math.random() * 1000,
          reflectionAngle: Math.random() * Math.PI * 2,
          isPopping: false,
          popPhase: 0
        };
      });
    }

    lightenColor(color: string, amount: number): string {
      // Simple color lightening for hover effect
      const rgba = color.match(/\d+/g);
      if (rgba) {
        const r = Math.min(255, parseInt(rgba[0]) + amount * 255);
        const g = Math.min(255, parseInt(rgba[1]) + amount * 255);
        const b = Math.min(255, parseInt(rgba[2]) + amount * 255);
        return `rgba(${r}, ${g}, ${b}, ${rgba[3] || 0.6})`;
      }
      return color;
    }

    handleMouseMove(e: MouseEvent) {
      const rect = this.canvas.getBoundingClientRect();
      this.mouse.x = e.clientX - rect.left;
      this.mouse.y = e.clientY - rect.top;
    }

    handleClick(e: MouseEvent) {
      // Check if click target is the hero button or its children
      const target = e.target as HTMLElement;
      const heroButton = document.querySelector('.hero-button') as HTMLElement;
      if (heroButton && (target === heroButton || heroButton.contains(target))) {
        return;
      }
      
      const rect = this.canvas.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;
      
      // Only process clicks within canvas bounds
      if (clickX < 0 || clickX > rect.width || clickY < 0 || clickY > rect.height) {
        return;
      }
      
      // Check if click is on a shape
      for (const shape of this.shapes) {
        if (shape.life !== undefined) continue; // Skip explosion particles
        
        const distance = Math.sqrt(
          Math.pow(shape.x - clickX, 2) + 
          Math.pow(shape.y - clickY, 2)
        );
        
        if (distance < shape.radius) {
          e.preventDefault();
          this.explodeShape(shape);
          break; // Only pop one bubble per click
        }
      }
    }

    bindEvents() {
      window.addEventListener('resize', this.resizeHandler);
      document.addEventListener('mousemove', this.mouseMoveHandler);
      document.addEventListener('click', this.clickHandler);
    }

    unbindEvents() {
      window.removeEventListener('resize', this.resizeHandler);
      document.removeEventListener('mousemove', this.mouseMoveHandler);
      document.removeEventListener('click', this.clickHandler);
    }

    explodeShape(shape: FloatingShape) {
      // Create explosion effect
      for (let i = 0; i < 12; i++) {
        const angle = (i / 12) * Math.PI * 2;
        const distance = 60 + Math.random() * 40;
        const particle: FloatingShape = {
          x: shape.x,
          y: shape.y,
          vx: Math.cos(angle) * (distance / 20),
          vy: Math.sin(angle) * (distance / 20),
          radius: 3,
          mass: 3,
          color: shape.color,
          originalColor: shape.color,
          hoverColor: shape.color,
          isHovered: false,
          pulse: 0,
          pulseSpeed: 0,
          id: Date.now() + i,
          life: 60,
          size: 3
        };
        
        // Add particle to shapes array temporarily
        this.shapes.push(particle);
      }
      
      // Remove original shape
      this.shapes = this.shapes.filter(s => s.id !== shape.id);
      
      // Create new shape after explosion
      const timeoutId = setTimeout(() => {
        if (!this.isDestroyed) {
          this.createNewShape();
        }
      }, 1000);
      this.pendingTimeouts.push(timeoutId);
    }

    // Check if a position is safe (away from text and button)
    isPositionSafe(x: number, y: number, radius: number): boolean {
      const canvasRect = this.canvas.getBoundingClientRect();
      const minDistance = radius + 20; // Add 20px buffer to avoid immediate collision
      
      // Check distance from magnetic text
      let magneticText = document.querySelector('.magnetic-text');
      if (magneticText) {
        const rect = magneticText.getBoundingClientRect();
        const textLeft = rect.left - canvasRect.left;
        const textRight = rect.right - canvasRect.left;
        const textTop = rect.top - canvasRect.top;
        const textBottom = rect.bottom - canvasRect.top;
        const textCenterX = (textLeft + textRight) / 2;
        const textCenterY = (textTop + textBottom) / 2;
        
        const distanceToText = Math.sqrt(
          Math.pow(x - textCenterX, 2) + Math.pow(y - textCenterY, 2)
        );
        
        // Check if bubble would be too close to text (using expanded bounding box)
        const expandedTextWidth = (textRight - textLeft) / 2 + minDistance;
        const expandedTextHeight = (textBottom - textTop) / 2 + minDistance;
        
        if (distanceToText < Math.max(expandedTextWidth, expandedTextHeight)) {
          return false;
        }
      }
      
      // Check distance from hero button
      let heroButton = document.querySelector('.hero-button');
      if (heroButton) {
        const rect = heroButton.getBoundingClientRect();
        const buttonLeft = rect.left - canvasRect.left;
        const buttonRight = rect.right - canvasRect.left;
        const buttonTop = rect.top - canvasRect.top;
        const buttonBottom = rect.bottom - canvasRect.top;
        const buttonCenterX = (buttonLeft + buttonRight) / 2;
        const buttonCenterY = (buttonTop + buttonBottom) / 2;
        
        const distanceToButton = Math.sqrt(
          Math.pow(x - buttonCenterX, 2) + Math.pow(y - buttonCenterY, 2)
        );
        
        // Check if bubble would be too close to button (using expanded bounding box)
        const expandedButtonWidth = (buttonRight - buttonLeft) / 2 + minDistance;
        const expandedButtonHeight = (buttonBottom - buttonTop) / 2 + minDistance;
        
        if (distanceToButton < Math.max(expandedButtonWidth, expandedButtonHeight)) {
          return false;
        }
      }
      
      return true;
    }

    createNewShape() {
      // Random realistic soap bubble color set (very pale, translucent)
      const soapBubbleColorSets = [
        ['rgba(255, 230, 250, 0.15)', 'rgba(230, 250, 255, 0.18)', 'rgba(240, 255, 255, 0.12)'],
        ['rgba(240, 230, 255, 0.16)', 'rgba(230, 240, 255, 0.17)', 'rgba(230, 255, 250, 0.14)'],
        ['rgba(230, 245, 255, 0.17)', 'rgba(240, 255, 255, 0.16)', 'rgba(255, 240, 250, 0.15)'],
        ['rgba(235, 255, 240, 0.15)', 'rgba(230, 245, 255, 0.17)', 'rgba(245, 235, 255, 0.16)'],
        ['rgba(255, 250, 235, 0.14)', 'rgba(255, 235, 245, 0.16)', 'rgba(235, 245, 255, 0.15)'],
        ['rgba(235, 255, 255, 0.16)', 'rgba(245, 235, 255, 0.15)', 'rgba(255, 235, 250, 0.17)']
      ];
      
      const randomColors = soapBubbleColorSets[Math.floor(Math.random() * soapBubbleColorSets.length)];
      
      // Determine bubble size first
      const radius = Math.random() * 40 + 40;
      
      // Find a safe position away from text and button
      let x: number, y: number;
      let attempts = 0;
      const maxAttempts = 50; // Prevent infinite loop
      
      do {
        x = Math.random() * this.canvas.width;
        y = Math.random() * this.canvas.height;
        attempts++;
      } while (!this.isPositionSafe(x, y, radius) && attempts < maxAttempts);
      
      // If we couldn't find a safe position after many attempts, place it at the edges
      if (attempts >= maxAttempts) {
        // Place at one of the corners or edges, avoiding center where text/button likely are
        const corner = Math.floor(Math.random() * 4);
        switch (corner) {
          case 0: // Top-left
            x = radius + 20;
            y = radius + 20;
            break;
          case 1: // Top-right
            x = this.canvas.width - radius - 20;
            y = radius + 20;
            break;
          case 2: // Bottom-left
            x = radius + 20;
            y = this.canvas.height - radius - 20;
            break;
          case 3: // Bottom-right
            x = this.canvas.width - radius - 20;
            y = this.canvas.height - radius - 20;
            break;
        }
      }
      
      const newShape = {
        x: x,
        y: y,
        vx: (Math.random() - 0.5) * 2,
        vy: (Math.random() - 0.5) * 2,
        radius: radius,
        mass: radius,
        color: randomColors[0],
        colors: randomColors,
        originalColor: randomColors[0],
        hoverColor: this.lightenColor(randomColors[0], 0.3),
        isHovered: false,
        pulse: Math.random() * Math.PI * 2,
        pulseSpeed: Math.random() * 0.02 + 0.01,
        id: Date.now(),
        wobblePhase: Math.random() * Math.PI * 2,
        wobbleSpeed: Math.random() * 0.03 + 0.02,
        distortionSeed: Math.random() * 1000,
        reflectionAngle: Math.random() * Math.PI * 2,
        isPopping: false,
        popPhase: 0
      };
      
      this.shapes.push(newShape);
    }

    startPhysics() {
      if (this.isRunning) return;
      this.isRunning = true;
      this.physicsLoop();
    }

    physicsLoop() {
      if (!this.isRunning) return;
      
      this.updatePhysics();
      this.drawShapes();
      this.animationFrameId = requestAnimationFrame(() => this.physicsLoop());
    }

    // Cleanup method for proper memory management
    destroy() {
      if (!this.initialized) return;
      
      // Mark as destroyed to prevent operations
      this.isDestroyed = true;
      this.isRunning = false;
      
      // Cancel animation frame
      if (this.animationFrameId !== null) {
        cancelAnimationFrame(this.animationFrameId);
        this.animationFrameId = null;
      }
      
      // Clear all pending timeouts
      this.pendingTimeouts.forEach(timeoutId => clearTimeout(timeoutId));
      this.pendingTimeouts = [];
      
      // Remove event listeners
      if (this.unbindEvents) {
        this.unbindEvents();
      }
      
      // Clear shapes array
      this.shapes = [];
      
      // Clear canvas
      if (this.ctx && this.canvas) {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      }
    }

    // Check collision with interactive elements (text and buttons) - precise collision
    checkCollisionWithElements(shape: FloatingShape): boolean {
      const canvasRect = this.canvas.getBoundingClientRect();
      
      // Check collision with magnetic text - check if bubble edge touches text
      // Cache these queries - they're called every frame for every bubble!
      let magneticText = document.querySelector('.magnetic-text');
      if (magneticText) {
        const rect = magneticText.getBoundingClientRect();
        const textLeft = rect.left - canvasRect.left;
        const textRight = rect.right - canvasRect.left;
        const textTop = rect.top - canvasRect.top;
        const textBottom = rect.bottom - canvasRect.top;
        
        // Check if bubble edge (not center) intersects with text bounding box
        const bubbleLeft = shape.x - shape.radius;
        const bubbleRight = shape.x + shape.radius;
        const bubbleTop = shape.y - shape.radius;
        const bubbleBottom = shape.y + shape.radius;
        
        // Check for actual overlap (bubble edge touching text edge)
        if (bubbleRight > textLeft && bubbleLeft < textRight && 
            bubbleBottom > textTop && bubbleTop < textBottom) {
          // Additional check: ensure bubble is actually close enough to touch
          const closestX = Math.max(textLeft, Math.min(shape.x, textRight));
          const closestY = Math.max(textTop, Math.min(shape.y, textBottom));
          const distance = Math.sqrt(
            Math.pow(shape.x - closestX, 2) + Math.pow(shape.y - closestY, 2)
          );
          if (distance <= shape.radius + 2) { // Allow 2px tolerance for smooth popping
            return true;
          }
        }
      }
      
      // Check collision with hero button - precise collision
      // Cache this query too
      let heroButton = document.querySelector('.hero-button');
      if (heroButton) {
        const rect = heroButton.getBoundingClientRect();
        const buttonLeft = rect.left - canvasRect.left;
        const buttonRight = rect.right - canvasRect.left;
        const buttonTop = rect.top - canvasRect.top;
        const buttonBottom = rect.bottom - canvasRect.top;
        
        const bubbleLeft = shape.x - shape.radius;
        const bubbleRight = shape.x + shape.radius;
        const bubbleTop = shape.y - shape.radius;
        const bubbleBottom = shape.y + shape.radius;
        
        // Check for actual overlap
        if (bubbleRight > buttonLeft && bubbleLeft < buttonRight && 
            bubbleBottom > buttonTop && bubbleTop < buttonBottom) {
          // Additional check: ensure bubble is actually close enough to touch
          const closestX = Math.max(buttonLeft, Math.min(shape.x, buttonRight));
          const closestY = Math.max(buttonTop, Math.min(shape.y, buttonBottom));
          const distance = Math.sqrt(
            Math.pow(shape.x - closestX, 2) + Math.pow(shape.y - closestY, 2)
          );
          if (distance <= shape.radius + 2) { // Allow 2px tolerance for smooth popping
            return true;
          }
        }
      }
      
      return false;
    }
    
    // Check collision with mouse pointer
    checkCollisionWithMouse(shape: FloatingShape): boolean {
      const dx = this.mouse.x - shape.x;
      const dy = this.mouse.y - shape.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      // Bubble pops immediately when mouse pointer touches its edge
      return distance <= shape.radius;
    }

    updatePhysics() {
      const screenWidth = this.canvas.width;
      const screenHeight = this.canvas.height;

      // Iterate in reverse to avoid index issues when splicing
      for (let i = this.shapes.length - 1; i >= 0; i--) {
        const shape = this.shapes[i];
        const index = i;
        // Skip particles with life (explosion particles)
        if (shape.life !== undefined) {
          shape.life--;
          shape.x += shape.vx;
          shape.y += shape.vy;
          shape.vx *= 0.98;
          shape.vy *= 0.98;
          
          if (shape.life <= 0) {
            this.shapes.splice(index, 1);
            continue;
          }
          continue;
        }

        // Handle pop animation - pop immediately without shrinking
        if (shape.isPopping) {
          shape.popPhase = (shape.popPhase || 0) + 0.15; // Faster pop animation
          if (shape.popPhase >= 1) {
            // Pop complete - explode the bubble
            this.explodeShape(shape);
            continue; // Skip rest of processing for this shape
          }
        }

        // Check collision with mouse pointer
        if (!shape.isPopping && this.checkCollisionWithMouse(shape)) {
          shape.isPopping = true;
          shape.popPhase = 0;
        }

        // Check collision with interactive elements (text/button)
        if (!shape.isPopping && this.checkCollisionWithElements(shape)) {
          shape.isPopping = true;
          shape.popPhase = 0;
        }

        // Update wobble phase for wobbly edges
        if (shape.wobblePhase !== undefined && shape.wobbleSpeed !== undefined) {
          shape.wobblePhase += shape.wobbleSpeed;
        }

        // Reflection position based on vertical position (light from above)
        const normalizedY = shape.y / this.canvas.height;
        if (shape.reflectionAngle !== undefined) {
          shape.reflectionAngle = normalizedY * 0.3 - 0.15;
        }

        // Update position
        shape.x += shape.vx;
        shape.y += shape.vy;

        // Check if bubble has drifted completely off-screen
        const isFullyOffScreen = 
          (shape.x + shape.radius < 0) || 
          (shape.x - shape.radius > screenWidth) ||
          (shape.y + shape.radius < 0) || 
          (shape.y - shape.radius > screenHeight);

        if (isFullyOffScreen) {
          // Remove bubble and recreate at random location
          this.shapes.splice(index, 1);
          this.createNewShape();
          continue; // Continue to next shape
        }

        // Gentle mouse interaction (attraction, but don't pop)
        const dx = this.mouse.x - shape.x;
        const dy = this.mouse.y - shape.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < 120 && distance > shape.radius + 5) {
          const force = (120 - distance) / 120;
          shape.vx += (dx / distance) * force * 0.0002;
          shape.vy += (dy / distance) * force * 0.0002;
        }

        // Hover detection for visual feedback
        shape.isHovered = distance < shape.radius;

        // Update pulse
        shape.pulse += shape.pulseSpeed;
      }
    }

    // Generate perfectly spherical bubble
    generateWobblyPath(shape: FloatingShape): Path2D {
      const path = new Path2D();
      const baseRadius = shape.radius;
      const pulseSize = baseRadius + Math.sin(shape.pulse) * 0.5;
      
      // Draw a perfect circle
      path.arc(shape.x, shape.y, pulseSize, 0, Math.PI * 2);
      path.closePath();
      return path;
    }

    drawShapes() {
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

      // Draw all shapes
      for (const shape of this.shapes) {
        if (shape.life !== undefined) {
          // Draw explosion particle
          this.ctx.save();
          this.ctx.globalAlpha = shape.life / 60;
          this.ctx.fillStyle = shape.color;
          this.ctx.beginPath();
          this.ctx.arc(shape.x, shape.y, shape.size || 3, 0, Math.PI * 2);
          this.ctx.fill();
          this.ctx.restore();
          continue; // Continue to next shape, don't exit function
        }

        // Skip rendering if popping is complete (will be removed next frame)
        if (shape.isPopping && (shape.popPhase || 0) >= 1) {
          continue; // Skip this shape, continue to next
        }

        this.ctx.save();
        
        // Generate wobbly path for irregular soap bubble shape
        const bubblePath = this.generateWobblyPath(shape);
        
        // Calculate current size (don't reduce during pop)
        const baseRadius = shape.radius;
        const pulseSize = baseRadius + Math.sin(shape.pulse) * 0.5;
        
        // Apply fade-out during pop animation
        const popPhase = shape.isPopping ? (shape.popPhase || 0) : 0;
        const bubbleAlpha = 1 - popPhase;
        
        // Create realistic soap bubble - very pale, translucent with iridescent edges
        // First, draw the main bubble body (very pale and translucent)
        if (shape.colors && shape.colors.length >= 3) {
          const mainGradient = this.ctx.createRadialGradient(
            shape.x - pulseSize * 0.35, shape.y - pulseSize * 0.35, 0,
            shape.x, shape.y, pulseSize
          );
          // Soap bubbles are mostly transparent with slight color tints at edges
          // Apply fade during pop
          mainGradient.addColorStop(0, `rgba(255, 255, 255, ${0.02 * bubbleAlpha})`);
          mainGradient.addColorStop(0.7, this.adjustAlpha(shape.colors[0], bubbleAlpha));
          mainGradient.addColorStop(0.85, this.adjustAlpha(shape.colors[1], bubbleAlpha));
          mainGradient.addColorStop(1, this.adjustAlpha(shape.colors[2], bubbleAlpha));
          
          this.ctx.fillStyle = mainGradient;
          this.ctx.fill(bubblePath);
        }
        
        // Add realistic soap bubble reflections (light from above, fixed orientation)
        // Reflection position varies slightly based on bubble's vertical position
        const reflectionOffset = shape.reflectionAngle || 0; // Small offset based on vertical position
        
        // Primary reflection - large bright white spot at top (light from above)
        // Fade reflection during pop
        const reflectionX = shape.x + reflectionOffset * pulseSize * 0.2;
        const reflectionY = shape.y - pulseSize * 0.3 + reflectionOffset * pulseSize * 0.1;
        const primaryReflection = this.ctx.createRadialGradient(
          reflectionX, reflectionY, 0,
          reflectionX, reflectionY, pulseSize * 0.4
        );
        primaryReflection.addColorStop(0, `rgba(255, 255, 255, ${0.95 * bubbleAlpha})`);
        primaryReflection.addColorStop(0.25, `rgba(255, 255, 255, ${0.7 * bubbleAlpha})`);
        primaryReflection.addColorStop(0.5, `rgba(255, 255, 255, ${0.3 * bubbleAlpha})`);
        primaryReflection.addColorStop(0.75, `rgba(255, 255, 255, ${0.1 * bubbleAlpha})`);
        primaryReflection.addColorStop(1, 'rgba(255, 255, 255, 0)');
        this.ctx.fillStyle = primaryReflection;
        this.ctx.fill(bubblePath);
        
        // Secondary reflection - smaller highlight slightly below primary
        // Fade reflection during pop
        const secondaryX = shape.x + reflectionOffset * pulseSize * 0.15;
        const secondaryY = shape.y - pulseSize * 0.15 + reflectionOffset * pulseSize * 0.08;
        const secondaryReflection = this.ctx.createRadialGradient(
          secondaryX, secondaryY, 0,
          secondaryX, secondaryY, pulseSize * 0.25
        );
        secondaryReflection.addColorStop(0, `rgba(255, 255, 255, ${0.6 * bubbleAlpha})`);
        secondaryReflection.addColorStop(0.5, `rgba(255, 255, 255, ${0.2 * bubbleAlpha})`);
        secondaryReflection.addColorStop(1, 'rgba(255, 255, 255, 0)');
        this.ctx.fillStyle = secondaryReflection;
        this.ctx.fill(bubblePath);
        
        // Soft gradient border instead of hard white border
        // Create border as a very soft outer glow that fades gradually
        // Fade border during pop
        this.ctx.shadowBlur = 10;
        this.ctx.shadowColor = `rgba(255, 255, 255, ${0.35 * bubbleAlpha})`;
        this.ctx.shadowOffsetX = 0;
        this.ctx.shadowOffsetY = 0;
        this.ctx.strokeStyle = `rgba(255, 255, 255, ${0.25 * bubbleAlpha})`;
        this.ctx.lineWidth = 0.5;
        this.ctx.stroke(bubblePath);
        
        // Reset shadow before additional drawing
        this.ctx.shadowBlur = 0;
        this.ctx.shadowColor = 'transparent';
        
        // Additional very subtle inner edge for soft depth
        this.ctx.strokeStyle = `rgba(255, 255, 255, ${0.1 * bubbleAlpha})`;
        this.ctx.lineWidth = 0.3;
        this.ctx.stroke(bubblePath);
        
        // If popping, add realistic burst effect with droplets
        if (shape.isPopping && popPhase > 0) {
          // Add small droplets/particles bursting outward
          // Draw droplets that start visible and fade as they expand
          const particleCount = Math.floor(popPhase * 15);
          for (let i = 0; i < particleCount; i++) {
            const angle = (i / 15) * Math.PI * 2 + (Math.random() - 0.5) * 0.5;
            const dist = pulseSize * (0.3 + popPhase * 1.2);
            const px = shape.x + Math.cos(angle) * dist;
            const py = shape.y + Math.sin(angle) * dist;
            const particleSize = 2 + Math.random() * 3;
            
            // Droplets are most visible at mid-pop, fade out as they get further
            const distanceFactor = Math.min(1, dist / (pulseSize * 1.5));
            const particleAlpha = (1 - distanceFactor * 0.7) * (1 - popPhase * 0.3);
            
            const particleColor = shape.colors ? shape.colors[i % shape.colors.length] : shape.color;
            this.ctx.fillStyle = this.adjustAlpha(particleColor, particleAlpha);
            this.ctx.beginPath();
            this.ctx.arc(px, py, particleSize, 0, Math.PI * 2);
            this.ctx.fill();
          }
        }
        
        this.ctx.restore();
      }
    }

    adjustAlpha(color: string, alpha: number): string {
      // Match rgba values - format is rgba(r, g, b, a) where a is 0-1
      const match = color.match(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\d.]+)\)/);
      if (match) {
        const r = match[1];
        const g = match[2];
        const b = match[3];
        const originalAlpha = parseFloat(match[4]);
        return `rgba(${r}, ${g}, ${b}, ${originalAlpha * alpha})`;
      }
      return color;
    }

    darkenColor(color: string, amount: number): string {
      const rgba = color.match(/\d+/g);
      if (rgba) {
        const r = Math.max(0, parseInt(rgba[0]) - amount * 255);
        const g = Math.max(0, parseInt(rgba[1]) - amount * 255);
        const b = Math.max(0, parseInt(rgba[2]) - amount * 255);
        return `rgba(${r}, ${g}, ${b}, ${rgba[3] || 0.6})`;
      }
      return color;
    }
  }

  // Initialize canvas-based floating shapes when DOM is loaded
  let floatingShapesCanvas: FloatingShapesCanvas | null = null;

  document.addEventListener('DOMContentLoaded', function() {
    try {
      // Clean up any existing instance
      const existing = (window as any).floatingShapesCanvas;
      if (existing && typeof existing.destroy === 'function' && existing.initialized) {
        existing.destroy();
      }
      
      floatingShapesCanvas = new FloatingShapesCanvas();
      
      // Only assign if properly initialized
      if (floatingShapesCanvas.initialized) {
        (window as any).floatingShapesCanvas = floatingShapesCanvas;
      } else {
        console.warn('FloatingShapesCanvas: Failed to initialize properly');
        floatingShapesCanvas = null;
      }
    } catch (e) {
      console.error('FloatingShapesCanvas: Error during initialization:', e);
      floatingShapesCanvas = null;
    }
  });

  // Cleanup on page unload to prevent memory leaks
  window.addEventListener('beforeunload', function() {
    if (floatingShapesCanvas && typeof floatingShapesCanvas.destroy === 'function') {
      floatingShapesCanvas.destroy();
      floatingShapesCanvas = null;
    }
    const existing = (window as any).floatingShapesCanvas;
    if (existing && typeof existing.destroy === 'function') {
      existing.destroy();
      (window as any).floatingShapesCanvas = null;
    }
  });
</script>

<style>
  #floatingShapesCanvas {
    position: absolute !important;
    top: 0 !important;
    left: 0 !important;
    right: 0 !important;
    bottom: 0 !important;
    width: 100% !important;
    height: 100% !important;
    z-index: 3 !important;
    pointer-events: none !important;
  }
</style>
