---
// FloatingShapesCanvas.astro - Canvas-based floating shapes with physics
---

<canvas id="floatingShapesCanvas" class="absolute inset-0 w-full h-full pointer-events-auto"></canvas>

<script>
  // TypeScript interfaces
  interface FloatingShape {
    x: number;
    y: number;
    vx: number;
    vy: number;
    radius: number;
    mass: number;
    color: string;
    colors?: string[]; // Array of gradient colors for iridescent effect
    originalColor: string;
    hoverColor: string;
    isHovered: boolean;
    pulse: number;
    pulseSpeed: number;
    id: number;
    life?: number;
    size?: number;
  }

  interface MousePosition {
    x: number;
    y: number;
  }

  // Canvas-based Floating Shapes Physics System
  class FloatingShapesCanvas {
    canvas: HTMLCanvasElement;
    ctx: CanvasRenderingContext2D;
    shapes: FloatingShape[];
    isRunning: boolean;
    mouse: MousePosition;
    animationFrameId: number | null = null;
    resizeHandler: () => void;
    mouseMoveHandler: (e: MouseEvent) => void;
    clickHandler: (e: MouseEvent) => void;

    constructor() {
      this.canvas = document.getElementById('floatingShapesCanvas') as HTMLCanvasElement;
      if (!this.canvas) {
        return;
      }
      
      const ctx = this.canvas.getContext('2d');
      if (!ctx) {
        return;
      }
      
      this.ctx = ctx;
      this.shapes = [];
      this.isRunning = false;
      this.mouse = { x: 0, y: 0 };
      
      // Bind handlers to preserve context
      this.resizeHandler = () => this.resizeCanvas();
      this.mouseMoveHandler = (e: MouseEvent) => this.handleMouseMove(e);
      this.clickHandler = (e: MouseEvent) => this.handleClick(e);
      
      this.init();
    }

    init() {
      this.resizeCanvas();
      this.createShapes();
      this.bindEvents();
      this.startPhysics();
    }

    resizeCanvas() {
      this.canvas.width = window.innerWidth;
      this.canvas.height = window.innerHeight;
    }

    createShapes() {
      // Create 6 floating bubbles with iridescent colors
      const iridescentColors = [
        // Shape 1: 80px - pink/cyan/yellow gradient
        ['rgba(255, 0, 150, 0.7)', 'rgba(0, 255, 255, 0.7)', 'rgba(255, 255, 0, 0.7)'],
        // Shape 2: 120px - pink/green/purple gradient
        ['rgba(255, 100, 200, 0.7)', 'rgba(100, 255, 100, 0.7)', 'rgba(200, 100, 255, 0.7)'],
        // Shape 3: 60px - blue/yellow/purple gradient
        ['rgba(0, 200, 255, 0.7)', 'rgba(255, 200, 0, 0.7)', 'rgba(200, 0, 255, 0.7)'],
        // Shape 4: 100px - orange/blue/purple gradient
        ['rgba(255, 150, 0, 0.7)', 'rgba(0, 150, 255, 0.7)', 'rgba(150, 0, 255, 0.7)'],
        // Shape 5: 40px - yellow/pink/cyan gradient
        ['rgba(200, 255, 0, 0.7)', 'rgba(255, 0, 200, 0.7)', 'rgba(0, 200, 255, 0.7)'],
        // Shape 6: 90px - magenta/green/orange gradient
        ['rgba(255, 0, 255, 0.7)', 'rgba(0, 255, 150, 0.7)', 'rgba(255, 150, 0, 0.7)']
      ];

      const shapeConfigs = [
        { size: 80, colors: iridescentColors[0], x: 0.1, y: 0.1 },
        { size: 120, colors: iridescentColors[1], x: 0.85, y: 0.2 },
        { size: 60, colors: iridescentColors[2], x: 0.2, y: 0.8 },
        { size: 100, colors: iridescentColors[3], x: 0.75, y: 0.7 },
        { size: 40, colors: iridescentColors[4], x: 0.05, y: 0.5 },
        { size: 90, colors: iridescentColors[5], x: 0.9, y: 0.6 }
      ];

      this.shapes = shapeConfigs.map((config, index) => ({
        x: config.x * this.canvas.width,
        y: config.y * this.canvas.height,
        vx: (Math.random() - 0.5) * 2,
        vy: (Math.random() - 0.5) * 2,
        radius: config.size / 2,
        mass: config.size / 2,
        color: config.colors[0], // Primary color for explosion particles
        colors: config.colors, // Array of gradient colors
        originalColor: config.colors[0],
        hoverColor: this.lightenColor(config.colors[0], 0.3),
        isHovered: false,
        pulse: Math.random() * Math.PI * 2,
        pulseSpeed: Math.random() * 0.02 + 0.01,
        id: index
      }));
    }

    lightenColor(color: string, amount: number): string {
      // Simple color lightening for hover effect
      const rgba = color.match(/\d+/g);
      if (rgba) {
        const r = Math.min(255, parseInt(rgba[0]) + amount * 255);
        const g = Math.min(255, parseInt(rgba[1]) + amount * 255);
        const b = Math.min(255, parseInt(rgba[2]) + amount * 255);
        return `rgba(${r}, ${g}, ${b}, ${rgba[3] || 0.6})`;
      }
      return color;
    }

    handleMouseMove(e: MouseEvent) {
      const rect = this.canvas.getBoundingClientRect();
      this.mouse.x = e.clientX - rect.left;
      this.mouse.y = e.clientY - rect.top;
    }

    handleClick(e: MouseEvent) {
      // Check if click target is the hero button or its children
      const target = e.target as HTMLElement;
      const heroButton = document.querySelector('.hero-button') as HTMLElement;
      if (heroButton && (target === heroButton || heroButton.contains(target))) {
        return;
      }
      
      const rect = this.canvas.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;
      
      // Only process clicks within canvas bounds
      if (clickX < 0 || clickX > rect.width || clickY < 0 || clickY > rect.height) {
        return;
      }
      
      // Check if click is on a shape
      this.shapes.forEach(shape => {
        if (shape.life !== undefined) return; // Skip explosion particles
        
        const distance = Math.sqrt(
          Math.pow(shape.x - clickX, 2) + 
          Math.pow(shape.y - clickY, 2)
        );
        
        if (distance < shape.radius) {
          e.preventDefault();
          this.explodeShape(shape);
        }
      });
    }

    bindEvents() {
      window.addEventListener('resize', this.resizeHandler);
      document.addEventListener('mousemove', this.mouseMoveHandler);
      document.addEventListener('click', this.clickHandler);
    }

    unbindEvents() {
      window.removeEventListener('resize', this.resizeHandler);
      document.removeEventListener('mousemove', this.mouseMoveHandler);
      document.removeEventListener('click', this.clickHandler);
    }

    explodeShape(shape: FloatingShape) {
      // Create explosion effect
      for (let i = 0; i < 12; i++) {
        const angle = (i / 12) * Math.PI * 2;
        const distance = 60 + Math.random() * 40;
        const particle: FloatingShape = {
          x: shape.x,
          y: shape.y,
          vx: Math.cos(angle) * (distance / 20),
          vy: Math.sin(angle) * (distance / 20),
          radius: 3,
          mass: 3,
          color: shape.color,
          originalColor: shape.color,
          hoverColor: shape.color,
          isHovered: false,
          pulse: 0,
          pulseSpeed: 0,
          id: Date.now() + i,
          life: 60,
          size: 3
        };
        
        // Add particle to shapes array temporarily
        this.shapes.push(particle);
      }
      
      // Remove original shape
      this.shapes = this.shapes.filter(s => s.id !== shape.id);
      
      // Create new shape after explosion
      setTimeout(() => {
        this.createNewShape();
      }, 1000);
    }

    createNewShape() {
      // Random iridescent color set
      const iridescentColorSets = [
        ['rgba(255, 0, 150, 0.7)', 'rgba(0, 255, 255, 0.7)', 'rgba(255, 255, 0, 0.7)'],
        ['rgba(255, 100, 200, 0.7)', 'rgba(100, 255, 100, 0.7)', 'rgba(200, 100, 255, 0.7)'],
        ['rgba(0, 200, 255, 0.7)', 'rgba(255, 200, 0, 0.7)', 'rgba(200, 0, 255, 0.7)'],
        ['rgba(255, 150, 0, 0.7)', 'rgba(0, 150, 255, 0.7)', 'rgba(150, 0, 255, 0.7)'],
        ['rgba(200, 255, 0, 0.7)', 'rgba(255, 0, 200, 0.7)', 'rgba(0, 200, 255, 0.7)'],
        ['rgba(255, 0, 255, 0.7)', 'rgba(0, 255, 150, 0.7)', 'rgba(255, 150, 0, 0.7)'],
        ['rgba(150, 0, 255, 0.7)', 'rgba(255, 255, 0, 0.7)', 'rgba(0, 255, 200, 0.7)'],
        ['rgba(0, 255, 255, 0.7)', 'rgba(255, 0, 150, 0.7)', 'rgba(255, 200, 0, 0.7)']
      ];
      
      const randomColors = iridescentColorSets[Math.floor(Math.random() * iridescentColorSets.length)];
      
      const newShape = {
        x: Math.random() * this.canvas.width,
        y: Math.random() * this.canvas.height,
        vx: (Math.random() - 0.5) * 2,
        vy: (Math.random() - 0.5) * 2,
        radius: Math.random() * 40 + 40,
        mass: Math.random() * 40 + 40,
        color: randomColors[0],
        colors: randomColors,
        originalColor: randomColors[0],
        hoverColor: '',
        isHovered: false,
        pulse: Math.random() * Math.PI * 2,
        pulseSpeed: Math.random() * 0.02 + 0.01,
        id: Date.now()
      };
      
      newShape.hoverColor = this.lightenColor(newShape.color, 0.3);
      
      this.shapes.push(newShape);
    }

    startPhysics() {
      if (this.isRunning) return;
      this.isRunning = true;
      this.physicsLoop();
    }

    physicsLoop() {
      if (!this.isRunning) return;
      
      this.updatePhysics();
      this.drawShapes();
      this.animationFrameId = requestAnimationFrame(() => this.physicsLoop());
    }

    // Cleanup method for proper memory management
    destroy() {
      this.isRunning = false;
      
      // Cancel animation frame
      if (this.animationFrameId !== null) {
        cancelAnimationFrame(this.animationFrameId);
        this.animationFrameId = null;
      }
      
      // Remove event listeners
      this.unbindEvents();
      
      // Clear shapes array
      this.shapes = [];
      
      // Clear canvas
      if (this.ctx) {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      }
    }

    updatePhysics() {
      const screenWidth = this.canvas.width;
      const screenHeight = this.canvas.height;

      this.shapes.forEach((shape, index) => {
        // Skip particles with life (explosion particles)
        if (shape.life !== undefined) {
          shape.life--;
          shape.x += shape.vx;
          shape.y += shape.vy;
          shape.vx *= 0.98;
          shape.vy *= 0.98;
          
          if (shape.life <= 0) {
            this.shapes.splice(index, 1);
            return;
          }
          return;
        }

        // Update position
        shape.x += shape.vx;
        shape.y += shape.vy;

        // Screen edge collisions
        if (shape.x - shape.radius <= 0) {
          shape.x = shape.radius;
          shape.vx = Math.abs(shape.vx);
        }
        if (shape.x + shape.radius >= screenWidth) {
          shape.x = screenWidth - shape.radius;
          shape.vx = -Math.abs(shape.vx);
        }
        if (shape.y - shape.radius <= 0) {
          shape.y = shape.radius;
          shape.vy = Math.abs(shape.vy);
        }
        if (shape.y + shape.radius >= screenHeight) {
          shape.y = screenHeight - shape.radius;
          shape.vy = -Math.abs(shape.vy);
        }

        // Shape-to-shape collisions
        for (let otherIndex = index + 1; otherIndex < this.shapes.length; otherIndex++) {
          const otherShape = this.shapes[otherIndex];
          if (otherShape.life !== undefined) continue; // Skip particles
          
          const dx = shape.x - otherShape.x;
          const dy = shape.y - otherShape.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const minDistance = shape.radius + otherShape.radius;

          if (distance < minDistance && distance > 0) {
            // Collision detected
            const overlap = minDistance - distance;
            const separationX = (dx / distance) * overlap * 0.5;
            const separationY = (dy / distance) * overlap * 0.5;

            // Separate shapes
            shape.x += separationX;
            shape.y += separationY;
            otherShape.x -= separationX;
            otherShape.y -= separationY;

            // Calculate new velocities (elastic collision)
            const relativeVelocityX = shape.vx - otherShape.vx;
            const relativeVelocityY = shape.vy - otherShape.vy;
            const relativeVelocityDotProduct = relativeVelocityX * dx + relativeVelocityY * dy;
            const impulse = (2 * relativeVelocityDotProduct) / (shape.mass + otherShape.mass) / distance;

            shape.vx -= impulse * otherShape.mass * dx / distance;
            shape.vy -= impulse * otherShape.mass * dy / distance;
            otherShape.vx += impulse * shape.mass * dx / distance;
            otherShape.vy += impulse * shape.mass * dy / distance;
          }
        }

        // Mouse interaction
        const dx = this.mouse.x - shape.x;
        const dy = this.mouse.y - shape.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < 120) {
          const force = (120 - distance) / 120;
          shape.vx += (dx / distance) * force * 0.0002;
          shape.vy += (dy / distance) * force * 0.0002;
        }

        // Hover detection
        shape.isHovered = distance < shape.radius;

        // Update pulse
        shape.pulse += shape.pulseSpeed;
      });
    }

    drawShapes() {
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

      this.shapes.forEach(shape => {
        if (shape.life !== undefined) {
        // Draw explosion particle
        this.ctx.save();
        this.ctx.globalAlpha = shape.life / 60;
        this.ctx.fillStyle = shape.color;
        this.ctx.beginPath();
        this.ctx.arc(shape.x, shape.y, shape.size || 3, 0, Math.PI * 2);
          this.ctx.fill();
          this.ctx.restore();
          return;
        }

        // Draw main shape with iridescent gradient
        this.ctx.save();
        
        // Pulse effect
        const pulseSize = shape.radius + Math.sin(shape.pulse) * 2;
        
        // Create iridescent radial gradient using the colors array
        const gradient = this.ctx.createRadialGradient(
          shape.x - pulseSize * 0.3, shape.y - pulseSize * 0.3, 0,
          shape.x, shape.y, pulseSize
        );
        
        // Use iridescent colors if available, otherwise fallback to single color
        if (shape.colors && shape.colors.length >= 3) {
          gradient.addColorStop(0, shape.colors[0]); // Center color
          gradient.addColorStop(0.5, shape.colors[1]); // Mid color
          gradient.addColorStop(1, shape.colors[2]); // Edge color
        } else {
          const currentColor = shape.isHovered ? shape.hoverColor : shape.originalColor;
          gradient.addColorStop(0, currentColor);
          gradient.addColorStop(1, this.darkenColor(currentColor, 0.3));
        }
        
        // Draw main bubble
        this.ctx.fillStyle = gradient;
        this.ctx.beginPath();
        this.ctx.arc(shape.x, shape.y, pulseSize, 0, Math.PI * 2);
        this.ctx.fill();
        
        // Add inner highlight for bubble effect
        const highlightGradient = this.ctx.createRadialGradient(
          shape.x - pulseSize * 0.3, shape.y - pulseSize * 0.3, 0,
          shape.x - pulseSize * 0.3, shape.y - pulseSize * 0.3, pulseSize * 0.6
        );
        highlightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.3)');
        highlightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
        this.ctx.fillStyle = highlightGradient;
        this.ctx.fill();
        
        // Add border
        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.arc(shape.x, shape.y, pulseSize, 0, Math.PI * 2);
        this.ctx.stroke();
        
        // Add glow/shadow effect
        this.ctx.shadowBlur = 20;
        this.ctx.shadowColor = shape.colors ? shape.colors[0] : shape.color;
        this.ctx.beginPath();
        this.ctx.arc(shape.x, shape.y, pulseSize, 0, Math.PI * 2);
        this.ctx.stroke();
        
        this.ctx.restore();
      });
    }

    darkenColor(color: string, amount: number): string {
      const rgba = color.match(/\d+/g);
      if (rgba) {
        const r = Math.max(0, parseInt(rgba[0]) - amount * 255);
        const g = Math.max(0, parseInt(rgba[1]) - amount * 255);
        const b = Math.max(0, parseInt(rgba[2]) - amount * 255);
        return `rgba(${r}, ${g}, ${b}, ${rgba[3] || 0.6})`;
      }
      return color;
    }
  }

  // Initialize canvas-based floating shapes when DOM is loaded
  let floatingShapesCanvas: FloatingShapesCanvas | null = null;

  document.addEventListener('DOMContentLoaded', function() {
    try {
      // Clean up any existing instance
      if ((window as any).floatingShapesCanvas) {
        (window as any).floatingShapesCanvas.destroy();
      }
      
      floatingShapesCanvas = new FloatingShapesCanvas();
      (window as any).floatingShapesCanvas = floatingShapesCanvas;
    } catch (e) {
      console.error('FloatingShapesCanvas: Error during initialization:', e);
    }
  });

  // Cleanup on page unload to prevent memory leaks
  window.addEventListener('beforeunload', function() {
    if (floatingShapesCanvas) {
      floatingShapesCanvas.destroy();
      floatingShapesCanvas = null;
    }
    if ((window as any).floatingShapesCanvas) {
      (window as any).floatingShapesCanvas.destroy();
      (window as any).floatingShapesCanvas = null;
    }
  });
</script>

<style>
  #floatingShapesCanvas {
    z-index: 20 !important;
    pointer-events: none !important;
  }
</style>
