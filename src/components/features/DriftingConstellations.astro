<canvas id="driftingConstellationsCanvas" class="absolute inset-0 w-full h-full pointer-events-none" style="z-index: 88; background: rgba(0,16,40,0.15);"></canvas>
<script is:inline>
(function(){
  const IAU_LONG = {
    And: 'Andromeda', Ant: 'Antlia', Aps: 'Apus', Aqr: 'Aquarius', Aql: 'Aquila', Ara: 'Ara', Ari: 'Aries', Aur: 'Auriga', Boo: 'Boötes', 
    Cae: 'Caelum', Cam: 'Camelopardalis', Cnc: 'Cancer', CVn: 'Canes Venatici', CMa: 'Canis Major', CMi: 'Canis Minor', Cap: 'Capricornus', Car: 'Carina', Cas: 'Cassiopeia', Cen: 'Centaurus', Cep: 'Cepheus', Cet: 'Cetus', Cha: 'Chamaeleon', Cir: 'Circinus', Col: 'Columba', Com: 'Coma Berenices', CrA: 'Corona Australis', CrB: 'Corona Borealis', Crv: 'Corvus', Crt: 'Crater', Cru: 'Crux', Cyg: 'Cygnus', Del: 'Delphinus', Dor: 'Dorado', Dra: 'Draco', Equ: 'Equuleus', Eri: 'Eridanus', For: 'Fornax', Gem: 'Gemini', Gru: 'Grus', Her: 'Hercules', Hor: 'Horologium', Hya: 'Hydra', Hyi: 'Hydrus', Ind: 'Indus', Lac: 'Lacerta', Leo: 'Leo', LMi: 'Leo Minor', Lep: 'Lepus', Lib: 'Libra', Lup: 'Lupus', Lyn: 'Lynx', Lyr: 'Lyra', Men: 'Mensa', Mic: 'Microscopium', Mon: 'Monoceros', Mus: 'Musca', Nor: 'Norma', Oct: 'Octans', Oph: 'Ophiuchus', Ori: 'Orion', Pav: 'Pavo', Peg: 'Pegasus', Per: 'Perseus', Phe: 'Phoenix', Pic: 'Pictor', Psc: 'Pisces', PsA: 'Piscis Austrinus', Pup: 'Puppis', Pyx: 'Pyxis', Ret: 'Reticulum', Sge: 'Sagitta', Sgr: 'Sagittarius', Sco: 'Scorpius', Scl: 'Sculptor', Sct: 'Scutum', Ser: 'Serpens', Sex: 'Sextans', Tau: 'Taurus', Tel: 'Telescopium', Tri: 'Triangulum', TrA: 'Triangulum Australe', Tuc: 'Tucana', UMa: 'Ursa Major', UMi: 'Ursa Minor', Vel: 'Vela', Vir: 'Virgo', Vol: 'Volans', Vul: 'Vulpecula'
  };
  let items = [], fullList = [], nextIdx = 0, currentN = 4, slotUseW = 0, slotUseScale = 1;
  const canvas = document.getElementById('driftingConstellationsCanvas');
  const ctx = canvas.getContext('2d');
  const DPR = Math.max(1, window.devicePixelRatio || 1);
  let w = 0, h = 0, running = true, paused = false;
  let burstParticles = [];
  let animationFrameId = null;
  let resizeHandler = null;
  const MAX_BURST_PARTICLES = 200;

  window.createDriftBurst = function(x, y) {
    const n = 16 + Math.floor(Math.random()*6);
    console.log('[DriftingConstellations] createDriftBurst called with', x, y, 'burst n=', n);
    for(let i=0;i<n;i++){
      const angle = Math.PI*2*i/n + Math.random()*0.25;
      const speed = 2.5 + Math.random()*1.1;
      burstParticles.push({x, y, vx:Math.cos(angle)*speed, vy:Math.sin(angle)*speed, life:26+Math.random()*8, maxLife:26+Math.random()*8, color:`hsl(${Math.floor(Math.random()*50)+190},98%,81%)`, size: 1.4+Math.random()*1.4 });
    }
    // Cap burst particles to prevent unbounded growth
    if (burstParticles.length > MAX_BURST_PARTICLES) {
      burstParticles.splice(0, burstParticles.length - MAX_BURST_PARTICLES);
    }
  };

  function drawBurstParticles(){
    for(let i=burstParticles.length-1;i>=0;--i){
      let p = burstParticles[i];
      const alpha = Math.max(0, p.life/p.maxLife);
      ctx.save();
      ctx.globalAlpha = 0.39*alpha;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
      ctx.fillStyle = p.color;
      ctx.shadowColor = p.color; ctx.shadowBlur = 8;
      ctx.fill();
      ctx.restore();
      p.x += p.vx;
      p.y += p.vy;
      p.vx *= 0.96; p.vy *= 0.96;
      --p.life;
      if(p.life<=0) burstParticles.splice(i,1);
    }
  }
  function computeBBox(constLines) {
    // First normalize RA values to 0-360 range
    let normalizedPoints = [];
    constLines.forEach(line => line.forEach(([x, y]) => {
      let nx = x;
      while (nx < 0) nx += 360;
      while (nx >= 360) nx -= 360;
      normalizedPoints.push({x: nx, y: y});
    }));
    
    if (normalizedPoints.length === 0) return { minX:0,maxX:0,minY:0,maxY:0,cx:0,cy:0, spanX:1, spanY:1 };
    
    // Get Y bounds
    minY = Math.min(...normalizedPoints.map(p => p.y));
    maxY = Math.max(...normalizedPoints.map(p => p.y));
    
    // For RA (X), handle wrapping by finding the largest gap
    let xs = normalizedPoints.map(p => p.x).sort((a,b) => a - b);
    let maxGap = 0;
    for (let i = 0; i < xs.length - 1; i++) {
      let gap = xs[i + 1] - xs[i];
      if (gap > maxGap) maxGap = gap;
    }
    // Check wrapping gap from last to first
    let wrapGap = (360 - xs[xs.length - 1]) + xs[0];
    if (wrapGap > maxGap) maxGap = wrapGap;
    
    let spanX = 360 - maxGap;
    
    // If still very large (>120 degrees), use percentile to ignore outliers
    if (spanX > 120 && xs.length > 10) {
      let q05Idx = Math.floor(xs.length * 0.05);
      let q95Idx = Math.floor(xs.length * 0.95);
      let middleXs = xs.slice(q05Idx, q95Idx + 1);
      if (middleXs.length > 1) {
        let middleMaxGap = 0;
        for (let i = 0; i < middleXs.length - 1; i++) {
          let gap = middleXs[i + 1] - middleXs[i];
          if (gap > middleMaxGap) middleMaxGap = gap;
        }
        let middleWrapGap = (360 - middleXs[middleXs.length - 1]) + middleXs[0];
        if (middleWrapGap > middleMaxGap) middleMaxGap = middleWrapGap;
        let percentileSpan = 360 - middleMaxGap;
        spanX = Math.min(spanX, percentileSpan);
      }
    }
    
    // Final cap at 80 degrees (to prevent cut-off constellations)
    if (spanX > 80) spanX = 80;
    
    minX = Math.min(...xs);
    maxX = Math.max(...xs);
    
    return { minX, maxX, minY, maxY, cx: (minX + maxX) / 2, cy: (minY + maxY) / 2, spanX, spanY: (maxY - minY) || 1 };
  }
  function fitConstellation(lines, bbox, scale) {
    return lines.map(line => line.map(([ra, dec]) => [(ra-bbox.cx)*scale, -(dec-bbox.cy)*scale]));
  }
  function buildConstellationGraphic(orig, bbox, scale) {
    // Pre-render constellation lines and stars to an offscreen canvas for performance
    const padding = 12;
    const width = bbox.spanX * scale + padding * 2;
    const height = bbox.spanY * scale + padding * 2;
    const off = document.createElement('canvas');
    off.width = Math.ceil(width * DPR);
    off.height = Math.ceil(height * DPR);
    const octx = off.getContext('2d');
    octx.setTransform(DPR,0,0,DPR,0,0);
    
    // Helper to normalize RA and adjust for wrapping
    function normalizeRA(ra) {
      let nra = ra;
      while (nra < 0) nra += 360;
      while (nra >= 360) nra -= 360;
      // If the constellation wraps, adjust coordinates to be relative to minX
      // For wrapping cases, we need to handle points that might be "behind" minX
      if (nra < bbox.minX && (bbox.maxX - bbox.minX) > 180) {
        // This is a wrapping case - point is on the "other side" of 360
        // Don't adjust, use as-is
        return nra;
      }
      return nra;
    }
    // Lines
    octx.save();
    octx.strokeStyle = 'rgba(255,255,255,0.56)';
    octx.lineWidth = 1.2;
    octx.shadowColor = 'rgba(255,255,255,0.18)';
    octx.shadowBlur = 4;
    orig.forEach(line => {
      if (line.length < 2) return;
      
      // For each line, normalize coordinates while maintaining continuity
      // If points are close together in original space, they should stay close after normalization
      let normalizedLine = line.map(([ra, dec]) => {
        let nra = normalizeRA(ra);
        return { ra: nra, dec: dec, origRa: ra };
      });
      
      // Maintain continuity by tracking relative angular distances between consecutive points
      // Start from first point and adjust each subsequent point to maintain original relative distances
      for (let i = 1; i < normalizedLine.length; i++) {
        let prevOrig = line[i-1][0];
        let currOrig = line[i][0];
        let prevAdjusted = normalizedLine[i-1].ra;
        
        // Calculate shortest angular distance in original coordinates
        let origDiff = currOrig - prevOrig;
        // Normalize to [-180, 180] range (shortest path)
        while (origDiff > 180) origDiff -= 360;
        while (origDiff < -180) origDiff += 360;
        
        // Expected adjusted RA should be prevAdjusted + origDiff
        let expectedRA = prevAdjusted + origDiff;
        
        // Current normalized RA
        let currNormalized = normalizedLine[i].ra;
        
        // Find which 360° offset of currNormalized is closest to expectedRA
        let bestRA = currNormalized;
        let minDist = Math.abs(currNormalized - expectedRA);
        for (let offset = -360; offset <= 360; offset += 360) {
          let candidate = currNormalized + offset;
          let dist = Math.abs(candidate - expectedRA);
          if (dist < minDist) {
            minDist = dist;
            bestRA = candidate;
          }
        }
        
        // Update to the best adjusted RA
        normalizedLine[i].ra = bestRA;
      }
      
      // Draw line using adjusted coordinates that maintain continuity
      octx.beginPath();
      let prevX = null;
      normalizedLine.forEach((pt, i) => {
        // pt.ra maintains relative positions but may be outside 0-360 range
        // Find the 360° offset that gives best canvas positioning
        let adjustedRA = pt.ra;
        
        // Try different 360° offsets to find best position
        let bestRA = adjustedRA;
        let bestX = null;
        let minPenalty = Infinity;
        
        for (let offset = -720; offset <= 720; offset += 360) {
          let candidateRA = adjustedRA + offset;
          let candidateX = padding + (candidateRA - bbox.minX) * scale;
          let penalty = 0;
          
          // Penalty for being far from canvas center
          penalty += Math.abs(candidateX - (width / 2)) * 0.1;
          
          // If not first point, strong penalty for being far from previous point
          if (prevX !== null) {
            let distFromPrev = Math.abs(candidateX - prevX);
            if (distFromPrev > width) {
              penalty += (distFromPrev - width) * 10; // Heavy penalty for very long segments
            } else {
              penalty += distFromPrev * 0.3; // Prefer staying close to previous point
            }
          }
          
          if (penalty < minPenalty) {
            minPenalty = penalty;
            bestRA = candidateRA;
            bestX = candidateX;
          }
        }
        
        let x = bestX !== null ? bestX : padding + (bestRA - bbox.minX) * scale;
        let y = padding + (bbox.maxY - pt.dec) * scale;
        
        // Clamp to prevent extremely long lines
        if (prevX !== null && Math.abs(x - prevX) > width * 1.5) {
          // Segment too long, clamp it
          x = prevX + Math.sign(x - prevX) * width * 1.5;
        }
        
        if (i === 0) {
          octx.moveTo(x, y);
        } else {
          octx.lineTo(x, y);
        }
        prevX = x;
      });
      octx.stroke();
    });
    octx.restore();
    // Simple stars at constellation points - no database lookup needed
    // Use same coordinate adjustments as lines to ensure stars align with line endpoints
    const used = new Set();
    orig.forEach((line, lineIdx) => {
      // Apply same normalization as used for lines
      let normalizedLine = line.map(([ra, dec]) => {
        let nra = normalizeRA(ra);
        return { ra: nra, dec: dec, origRa: ra };
      });
      
      // Apply same continuity adjustments as lines
      for (let i = 1; i < normalizedLine.length; i++) {
        let prevOrigStar = line[i-1][0];
        let currOrigStar = line[i][0];
        let prevAdjustedStar = normalizedLine[i-1].ra;
        let origDiff = currOrigStar - prevOrigStar;
        while (origDiff > 180) origDiff -= 360;
        while (origDiff < -180) origDiff += 360;
        let expectedRA = prevAdjustedStar + origDiff;
        let currNormalized = normalizedLine[i].ra;
        let bestRA = currNormalized;
        let minDist = Math.abs(currNormalized - expectedRA);
        for (let offset = -360; offset <= 360; offset += 360) {
          let candidate = currNormalized + offset;
          let dist = Math.abs(candidate - expectedRA);
          if (dist < minDist) {
            minDist = dist;
            bestRA = candidate;
          }
        }
        normalizedLine[i].ra = bestRA;
      }
      
      // Draw stars at adjusted positions
      normalizedLine.forEach((pt) => {
        const key = pt.ra.toFixed(2) + ',' + pt.dec.toFixed(2);
        if (used.has(key)) return; used.add(key);
        
        // Use same positioning logic as lines
        let adjustedRA = pt.ra;
        let bestRA = adjustedRA;
        let bestX = null;
        let minPenalty = Infinity;
        for (let offset = -720; offset <= 720; offset += 360) {
          let candidateRA = adjustedRA + offset;
          let candidateX = padding + (candidateRA - bbox.minX) * scale;
          let penalty = Math.abs(candidateX - (width / 2)) * 0.1;
          if (penalty < minPenalty) {
            minPenalty = penalty;
            bestRA = candidateRA;
            bestX = candidateX;
          }
        }
        let x = bestX !== null ? bestX : padding + (bestRA - bbox.minX) * scale;
        const y = padding + (bbox.maxY - pt.dec) * scale;
        
        // Simple white dot, size varies slightly for visual interest
        const size = 2.5 + Math.random() * 1.5;
        octx.save();
        octx.beginPath();
        octx.arc(x, y, size, 0, Math.PI * 2);
        octx.fillStyle = '#fff';
        octx.globalAlpha = 0.75 + Math.random() * 0.25;
        octx.shadowColor = '#fff';
        octx.shadowBlur = 6;
        octx.fill();
        octx.globalAlpha = 1;
        octx.shadowBlur = 0;
        octx.restore();
      });
    });
    return { canvas: off, drawW: width, drawH: height };
  }
  function drawLabel(text, x, y, slotWidth) {
    ctx.save();
    ctx.font = '18px system-ui, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillStyle = 'rgba(220, 226, 255, 0.20)';
    ctx.shadowColor = 'rgba(0,0,0,0.27)';
    ctx.shadowBlur = 9;
    ctx.globalCompositeOperation = 'lighter';
    ctx.fillText(text, x, y);
    ctx.globalCompositeOperation = 'source-over';
    ctx.restore();
  }
  function drawItem(item, slotW) {
    const { pos, id, canvas, drawW, drawH } = item;
    if (!canvas) {
      console.warn('[DriftingConstellations] No canvas for item', id);
      return;
    }
    // Draw the pre-rendered constellation
    ctx.drawImage(canvas, pos.x - drawW/2, pos.y - drawH/2);
    // Draw label below
    drawLabel(IAU_LONG[id]||id, pos.x, h - 32, slotW);
  }
  function slotStatisticWidth(fullList, h) {
    // Constellations should fill about 1/3 of screen height
    const slotH = h/3;
    let widths = fullList.map(f => {
      const bbox = computeBBox(f.geometry.coordinates);
      const scale = slotH / bbox.spanY;
      return bbox.spanX * scale;
    }).sort((a,b)=>a-b);
    // Median if fewer than 4
    if (widths.length < 4) return {slotW:widths[widths.length-1]||120, scale:slotH/(computeBBox(fullList[0].geometry.coordinates).spanY)};
    // 75th percentile
    const ix = Math.floor(widths.length*0.75)-1;
    // Find a typical (not maximum) scale for all:
    let bboxRef = computeBBox(fullList[ix].geometry.coordinates);
    let scale = slotH / bboxRef.spanY;
    return {slotW:widths[ix], scale};
  }
  function getVisibleCountBySlot(fullList, w, h) {
    let {slotW} = slotStatisticWidth(fullList, h);
    // Calculate how many can fit with spacing (aim for 4-6)
    let spacing = 40; // More spacing for larger constellations
    let n = Math.floor(w / (slotW + spacing));
    // Target: show 4-6 constellations, prefer 4 with good spacing
    if (n >= 4) {
      return Math.min(6, n); // Show 4-6 if they fit
    }
    // If less than 4 can fit, return what fits (but we'll adjust spacing below)
    return Math.max(1, Math.min(fullList.length, n));
  }
  function animate(slotW) {
    if (!running) {
      animationFrameId = null;
      return;
    }
    ctx.clearRect(0,0,w,h);
    if (!items || !items.length) {
      ctx.save(); ctx.font = '24px monospace'; ctx.textAlign = 'center'; ctx.fillStyle = 'rgba(240,255,255,0.22)'; ctx.fillText('NO CONSTELLATIONS TO SHOW', w/2, h/2); ctx.restore();
      animationFrameId = requestAnimationFrame(()=>animate(slotW));
      return;
    }
    // Update positions only if not paused
    if (!paused) {
      for (const it of items) { it.pos.x += it.vx; }
    }
    
    // Remove constellations that have drifted off the RIGHT side FIRST (only one per frame to avoid blocking)
    // Do this BEFORE checking if we need to spawn, so we know the actual count
    // Constellations drift to the RIGHT (positive vx), so remove when they're off the right edge
    // Remove from the END of the array (rightmost item) when it's fully off screen
    if (items.length && items[items.length - 1].pos.x - (slotUseW)/2 > w + 60) {
      const removedItem = items.pop();
      console.log('[DriftingConstellations] Removed', removedItem.id, 'that drifted off right edge at x=', removedItem.pos.x.toFixed(1));
      if (removedItem && removedItem.canvas) {
        removedItem.canvas = null;
      }
    }
    
    // Always maintain 4 constellations visible - spawn new ones as needed
    const targetCount = 4;
    while (items.length < targetCount && fullList && fullList.length > 0) {
      try {
        let idx = nextIdx % fullList.length;
        nextIdx++;
        const feature = fullList[idx];
        if (!feature || !feature.geometry || !feature.geometry.coordinates) {
          console.error('[DriftingConstellations] Invalid feature at index', idx);
          break;
        }
        const orig = feature.geometry.coordinates;
        const bbox = computeBBox(orig);
        const scale = slotUseScale;
        // Place new constellation to the LEFT of the leftmost one (so it enters from the left)
        // Since they drift right, new ones should appear on the left side
        const ox = items.length > 0 ? items[0].pos.x - slotW : slotW/2;
        const oy = h/2;
        const g = buildConstellationGraphic(orig,bbox,scale);
        if (g && g.canvas) {
          // Insert at the beginning of the array so leftmost items stay at index 0
          items.unshift({ id: feature.id, pos:{x:ox,y:oy}, bbox, scale, vx:(0.96+Math.random()*0.18)*2, canvas: g.canvas, drawW: g.drawW, drawH: g.drawH });
          console.log('[DriftingConstellations] Spawned', feature.id, 'at x=', ox.toFixed(1), 'nextIdx=', nextIdx);
        } else {
          console.error('[DriftingConstellations] Failed to build graphic for', feature.id);
        }
      } catch(e) {
        console.error('[DriftingConstellations] Error respawning constellation:', e);
        break;
      }
    }
    // Draw all items
    if (items.length < targetCount && fullList && fullList.length > 0) {
      console.warn('[DriftingConstellations] Drawing with only', items.length, 'items! Should have', targetCount, '+. fullList.length =', fullList.length);
    }
    for(const it of items){ 
      drawItem(it, slotW); 
    }
    drawBurstParticles();
    animationFrameId = requestAnimationFrame(()=>animate(slotW));
  }
  function setupItemsAndAnimate() {
    // Cancel any pending animation frame
    if (animationFrameId !== null) {
      cancelAnimationFrame(animationFrameId);
      animationFrameId = null;
    }
    // Clean up old items' offscreen canvases before clearing
    items.forEach(item => {
      if (item && item.canvas) {
        item.canvas = null;
      }
    });
    // Use a more typical non-outlier slot width/scale for all:
    // Constellations should fill 1/3 of screen height
    let stats = slotStatisticWidth(fullList, h);
    slotUseW = stats.slotW;
    slotUseScale = stats.scale;
    
    // Target: show 4 constellations on screen
    currentN = 4;
    items = [];
    nextIdx = currentN;
    
    // Calculate spacing to fit exactly 4 constellations on screen
    // We want: slotW * 4 <= w, where slotW = slotUseW + spacing
    // So: (slotUseW + spacing) * 4 <= w
    // spacing <= (w/4) - slotUseW
    const minSpacing = 20;
    const targetSpacing = Math.max(minSpacing, (w / currentN) - slotUseW);
    let slotW = slotUseW + targetSpacing;
    
    // If they still don't fit, we need to reduce constellation size slightly
    if ((slotW * currentN) > w) {
      // Calculate the maximum slotW that fits 4
      const maxSlotW = w / currentN;
      const maxConstellationW = maxSlotW - minSpacing;
      if (maxConstellationW > 0) {
        // Scale down proportionally
        const scaleFactor = maxConstellationW / slotUseW;
        slotUseScale = slotUseScale * scaleFactor;
        slotUseW = maxConstellationW;
        slotW = slotUseW + minSpacing;
      }
    }
    console.log('[DriftingConstellations] Initializing with', currentN, 'constellations, slotW=', slotW.toFixed(1), 'w=', w, 'h=', h, 'slotUseW=', slotUseW.toFixed(1), 'fullList.length=', fullList.length, 'totalWidthUsed=', (slotW * currentN).toFixed(1));
    for (let i=0; i<currentN; ++i) {
      const feature = fullList[i];
      const orig = feature.geometry.coordinates;
      const bbox = computeBBox(orig);
      const scale = slotUseScale;
      // Start constellations positioned across the visible screen, starting from the left edge
      // Position them so they're evenly distributed across the screen width
      // First one at slotW/2, then evenly spaced
      const totalWidthUsed = currentN * slotW;
      const startX = slotW / 2;
      const ox = startX + i * slotW;
      const oy = h/2;
      const g = buildConstellationGraphic(orig,bbox,scale);
      if (g && g.canvas) {
        items.push({ id: feature.id, pos:{x:ox,y:oy}, bbox, scale, vx:(0.96+Math.random()*0.18)*2, canvas: g.canvas, drawW: g.drawW, drawH: g.drawH });
        console.log('[DriftingConstellations] Created constellation', feature.id, 'at x=', ox.toFixed(1));
      } else {
        console.error('[DriftingConstellations] Failed to create graphic for', feature.id);
      }
    }
    console.log('[DriftingConstellations] Total items created:', items.length);
    animate(slotW);
  }
  function resize() {
    w = canvas.clientWidth; h = canvas.clientHeight;
    canvas.width = Math.floor(w * DPR);
    canvas.height = Math.floor(h * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  function cleanup() {
    running = false;
    if (animationFrameId !== null) {
      cancelAnimationFrame(animationFrameId);
      animationFrameId = null;
    }
    if (resizeHandler) {
      window.removeEventListener('resize', resizeHandler);
      resizeHandler = null;
    }
    // Clean up all offscreen canvases
    items.forEach(item => {
      if (item && item.canvas) {
        item.canvas = null;
      }
    });
    items = [];
    burstParticles = [];
    // Clear canvas
    if (ctx) {
      ctx.clearRect(0, 0, w, h);
    }
  }

  async function init() {
    resize();
    resizeHandler = () => {
      resize();
      if(fullList && fullList.length) setupItemsAndAnimate();
    };
    window.addEventListener('resize', resizeHandler);
    try {
      // Only load constellation lines - no star database needed!
      const clines = await fetch('/docs/constellations.lines.json').then(r=>r.json());
      fullList = clines.features;
      console.log('[DriftingConstellations] Loaded', fullList.length, 'constellations');
      if (!fullList.length) {
        ctx.save(); ctx.font = '24px monospace'; ctx.textAlign = 'center'; ctx.fillStyle = 'rgba(255,100,100,0.38)'; ctx.fillText('NO CONSTELLATIONS LOADED', w/2, h/2); ctx.restore();
        return;
      }
      // Ensure w and h are set before setup
      if (w === 0 || h === 0) {
        resize();
      }
      console.log('[DriftingConstellations] About to setup with w=', w, 'h=', h);
      setupItemsAndAnimate();
    } catch(e) {
      ctx.save(); ctx.font = '24px monospace'; ctx.textAlign = 'center'; ctx.fillStyle = 'rgba(255,100,100,0.65)'; ctx.fillText('DATA FETCH ERROR', w/2, h/2); ctx.restore();
    }
  }
  // Expose pause toggle function globally so hero section can call it
  window.toggleConstellationPause = () => {
    paused = !paused;
    console.log('[DriftingConstellations] Paused:', paused);
  };
  
  document.addEventListener('DOMContentLoaded', init);
  document.addEventListener('astro:before-preparation', () => { cleanup(); });
  window.addEventListener('beforeunload', () => { cleanup(); });
})();
</script>
