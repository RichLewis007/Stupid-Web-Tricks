---
// ConstellationSystem.astro - Simple particle constellation system with stable connections
---

<canvas id="particleCanvas" class="absolute inset-0 w-full h-full"></canvas>

<script>
  // Simple Particle interface
  interface Particle {
    x: number;
    y: number;
    vx: number;
    vy: number;
    size: number;
    hue: number;
    connections: number[]; // Stable list of connected particle indices
  }

  interface MousePosition {
    x: number;
    y: number;
  }

  // Simple Constellation System
  class ConstellationSystem {
    canvas: HTMLCanvasElement;
    ctx: CanvasRenderingContext2D;
    particles: Particle[] = [];
    mouse: MousePosition = { x: 0, y: 0 };
    animationFrameId: number | null = null;
    resizeHandler: () => void;
    mouseMoveHandler: (e: MouseEvent) => void;
    mouseLeaveHandler: () => void;
    isRunning: boolean = false;
    connectionDistance: number = 120; // Distance threshold for connections

    constructor() {
      this.canvas = document.getElementById('particleCanvas') as HTMLCanvasElement;
      if (!this.canvas) {
        console.error('[ConstellationSystem] Canvas element not found');
        return;
      }
      
      const ctx = this.canvas.getContext('2d', { alpha: true });
      if (!ctx) {
        console.error('[ConstellationSystem] Could not get 2D context');
        return;
      }
      
      this.ctx = ctx;
      
      // Bind handlers to preserve 'this' context
      this.resizeHandler = () => this.handleResize();
      this.mouseMoveHandler = (e: MouseEvent) => this.handleMouseMove(e);
      this.mouseLeaveHandler = () => this.handleMouseLeave();
      
      this.init();
    }

    init() {
      this.resizeCanvas();
      this.createParticles();
      this.establishConnections(); // Establish connections once, not per frame
      this.bindEvents();
      this.isRunning = true;
      this.animate();
    }

    resizeCanvas() {
      this.canvas.width = window.innerWidth;
      this.canvas.height = window.innerHeight;
      
      // Recreate particles on resize
      this.createParticles();
      this.establishConnections();
    }

    createParticles() {
      this.particles = [];
      
      // Calculate particle count based on screen size
      const screenArea = this.canvas.width * this.canvas.height;
      let particleCount = Math.floor(screenArea / 15000);
      particleCount = Math.max(30, Math.min(particleCount, 200));
      
      // Create particles
      const margin = 20;
      for (let i = 0; i < particleCount; i++) {
        this.particles.push({
          x: Math.random() * (this.canvas.width - 2 * margin) + margin,
          y: Math.random() * (this.canvas.height - 2 * margin) + margin,
          vx: (Math.random() - 0.5) * 0.5, // Slow drift velocity
          vy: (Math.random() - 0.5) * 0.5,
          size: Math.random() * 2 + 1,
          hue: Math.random() * 360,
          connections: []
        });
      }
    }

    establishConnections() {
      // Clear existing connections
      this.particles.forEach(p => p.connections = []);
      
      // Establish stable connections based on initial positions
      const connectionDistanceSq = this.connectionDistance * this.connectionDistance;
      const maxConnections = 4; // Limit connections per particle to reduce complexity
      
      for (let i = 0; i < this.particles.length; i++) {
        const p1 = this.particles[i];
        
        for (let j = i + 1; j < this.particles.length; j++) {
          if (p1.connections.length >= maxConnections) break;
          
          const p2 = this.particles[j];
          const dx = p1.x - p2.x;
          const dy = p1.y - p2.y;
          const distSq = dx * dx + dy * dy;
          
          // Establish connection if particles are close enough
          if (distSq < connectionDistanceSq) {
            p1.connections.push(j);
            if (p2.connections.length < maxConnections) {
              p2.connections.push(i);
            }
          }
        }
      }
    }

    handleResize() {
      if (!this.isRunning) return;
      this.resizeCanvas();
    }

    handleMouseMove(e: MouseEvent) {
      if (!this.isRunning) return;
      const rect = this.canvas.getBoundingClientRect();
      this.mouse.x = e.clientX - rect.left;
      this.mouse.y = e.clientY - rect.top;
    }

    handleMouseLeave() {
      if (!this.isRunning) return;
      this.mouse.x = 0;
      this.mouse.y = 0;
    }

    bindEvents() {
      window.addEventListener('resize', this.resizeHandler);
      this.canvas.addEventListener('mousemove', this.mouseMoveHandler);
      this.canvas.addEventListener('mouseleave', this.mouseLeaveHandler);
    }

    unbindEvents() {
      window.removeEventListener('resize', this.resizeHandler);
      this.canvas.removeEventListener('mousemove', this.mouseMoveHandler);
      this.canvas.removeEventListener('mouseleave', this.mouseLeaveHandler);
    }

    updateParticles() {
      if (!this.isRunning) return;
      
      this.particles.forEach(particle => {
        // Update position
        particle.x += particle.vx;
        particle.y += particle.vy;
        
        // Boundary bouncing with damping
        const margin = 10;
        if (particle.x < margin || particle.x > this.canvas.width - margin) {
          particle.vx *= -0.9;
          particle.x = Math.max(margin, Math.min(this.canvas.width - margin, particle.x));
        }
        if (particle.y < margin || particle.y > this.canvas.height - margin) {
          particle.vy *= -0.9;
          particle.y = Math.max(margin, Math.min(this.canvas.height - margin, particle.y));
        }
        
        // Gentle mouse interaction (optional, keeps particles away from cursor)
        if (this.mouse.x && this.mouse.y) {
          const dx = this.mouse.x - particle.x;
          const dy = this.mouse.y - particle.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < 80 && distance > 0) {
            const force = (80 - distance) / 80 * 0.05;
            particle.vx -= (dx / distance) * force;
            particle.vy -= (dy / distance) * force;
          }
        }
        
        // Apply friction
        particle.vx *= 0.995;
        particle.vy *= 0.995;
      });
    }

    drawParticles() {
      if (!this.isRunning) return;
      
      // Clear canvas
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      
      // Draw connecting lines (stable connections prevent flickering)
      this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
      this.ctx.lineWidth = 1;
      
      for (let i = 0; i < this.particles.length; i++) {
        const p1 = this.particles[i];
        
        // Draw lines to connected particles
        p1.connections.forEach(j => {
          const p2 = this.particles[j];
          // Only draw line if both particles still exist
          if (p2) {
            this.ctx.beginPath();
            this.ctx.moveTo(p1.x, p1.y);
            this.ctx.lineTo(p2.x, p2.y);
            this.ctx.stroke();
          }
        });
      }
      
      // Draw mouse connections (optional, lighter lines)
      if (this.mouse.x && this.mouse.y) {
        this.ctx.strokeStyle = 'rgba(100, 200, 255, 0.15)';
        for (let i = 0; i < this.particles.length; i++) {
          const p = this.particles[i];
          const dx = this.mouse.x - p.x;
          const dy = this.mouse.y - p.y;
          const distSq = dx * dx + dy * dy;
          
          if (distSq < this.connectionDistance * this.connectionDistance) {
            this.ctx.beginPath();
            this.ctx.moveTo(p.x, p.y);
            this.ctx.lineTo(this.mouse.x, this.mouse.y);
            this.ctx.stroke();
          }
        }
      }
      
      // Draw particles
      for (let i = 0; i < this.particles.length; i++) {
        const p = this.particles[i];
        this.ctx.save();
        this.ctx.beginPath();
        this.ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        this.ctx.fillStyle = `hsl(${p.hue}, 70%, 70%)`;
        this.ctx.globalAlpha = 0.8;
        this.ctx.fill();
        this.ctx.restore();
      }
    }

    animate() {
      if (!this.isRunning) return;
      
      this.updateParticles();
      this.drawParticles();
      
      this.animationFrameId = requestAnimationFrame(() => this.animate());
    }

    // Cleanup method to prevent memory leaks
    destroy() {
      this.isRunning = false;
      
      // Cancel animation frame
      if (this.animationFrameId !== null) {
        cancelAnimationFrame(this.animationFrameId);
        this.animationFrameId = null;
      }
      
      // Remove event listeners
      this.unbindEvents();
      
      // Clear arrays
      this.particles = [];
      
      // Clear canvas
      if (this.ctx) {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      }
    }
  }

  // Initialize constellation system
  let constellationSystem: ConstellationSystem | null = null;

  document.addEventListener('DOMContentLoaded', function() {
    try {
      // Clean up any existing instance
      if ((window as any).constellationSystem) {
        (window as any).constellationSystem.destroy();
      }
      
      // Create new instance
      constellationSystem = new ConstellationSystem();
      (window as any).constellationSystem = constellationSystem;
    } catch (e) {
      console.error('[ConstellationSystem] Error during initialization:', e);
    }
  });

  // Cleanup on page unload to prevent memory leaks
  window.addEventListener('beforeunload', function() {
    if (constellationSystem) {
      constellationSystem.destroy();
      constellationSystem = null;
    }
    if ((window as any).constellationSystem) {
      (window as any).constellationSystem.destroy();
      (window as any).constellationSystem = null;
    }
  });
</script>

<style>
  #particleCanvas {
    z-index: 1 !important;
    pointer-events: none !important;
  }
</style>
