---
// ConstellationSystem.astro - Interactive particle constellation system
---

<canvas id="particleCanvas" class="absolute inset-0 w-full h-full"></canvas>

<script>
  import type { Particle, ColorWave, MousePosition } from '../../types/index';

  let globalInitCount = 0;

  // Interactive Constellation Particle System
  class ConstellationSystem {
    canvas!: HTMLCanvasElement;
    ctx!: CanvasRenderingContext2D;
    particles: Particle[] = [];
    mouse: MousePosition = { x: 0, y: 0 };
    lastClickTime: number = 0;
    clickThrottle: number = 500;
    colorWaves: ColorWave[] = [];
    canClick: boolean = true;
    userInteracted: boolean = false;
    autoClickIntervalId: number | null = null;
    isRunning: boolean = true;

    constructor() {
      globalInitCount++;
      console.log('[ConstellationSystem] Constructor called', globalInitCount);
      this.canvas = document.getElementById('particleCanvas') as HTMLCanvasElement;
      if (!this.canvas) {
        console.error('[ConstellationSystem] Canvas element not found');
        return;
      }
      
      const ctx = this.canvas.getContext('2d');
      if (!ctx) {
        console.error('[ConstellationSystem] Could not get 2D context');
        return;
      }
      
      this.ctx = ctx;
      this.particles = [];
      this.mouse = { x: 0, y: 0 };
      this.lastClickTime = 0;
      this.clickThrottle = 500;
      this.canClick = true;
      this.colorWaves = []; // Array of active color waves
      this.userInteracted = false;
      this.autoClickIntervalId = null;
      try {
        this.init();
        console.log('[ConstellationSystem] Init completed');
      } catch (e) {
        console.error('[ConstellationSystem] Error during init:', e);
      }
    }

    init() {
      console.log('[ConstellationSystem] init() called');
      this.resizeCanvas();
      this.createParticles();
      this.establishConnections();
      this.bindEvents();
      this.animate();
      console.log('[ConstellationSystem] init() finished');
    }

    resizeCanvas() {
      console.log('[ConstellationSystem] resizeCanvas() called');
      this.canvas.width = window.innerWidth;
      this.canvas.height = window.innerHeight;
      
      // Recreate particles with new count based on screen size
      this.particles = [];
      this.createParticles();
      this.establishConnections();
      console.log('[ConstellationSystem] resizeCanvas() finished');
    }

    createParticles() {
      console.log('[ConstellationSystem] createParticles() called');
      // Adjust particle count based on screen size
      const screenArea = this.canvas.width * this.canvas.height;
      let particleCount;
      
      if (this.canvas.width <= 768) {
        // Mobile: fewer particles for better performance
        particleCount = Math.floor(screenArea / 20000);
      } else if (this.canvas.width <= 1024) {
        // Tablet: medium particle count
        particleCount = Math.floor(screenArea / 15000);
      } else {
        // Desktop: full particle count
        particleCount = Math.floor(screenArea / 12000);
      }
      
      // Ensure minimum and maximum particle counts
      particleCount = Math.max(20, Math.min(particleCount, 300));
      
      console.log(`Creating ${particleCount} particles for ${this.canvas.width}x${this.canvas.height} screen`);
      
      // Create particles with proper boundary constraints
      for (let i = 0; i < particleCount; i++) {
        const baseHue = Math.random() * 360;
        // Ensure particles stay within viewable area with margin
        const margin = 20; // 20px margin from edges
        const homeX = Math.random() * (this.canvas.width - 2 * margin) + margin;
        const homeY = Math.random() * (this.canvas.height - 2 * margin) + margin;
        
        this.particles.push({
          x: homeX,
          y: homeY,
          homeX: homeX, // Store home position
          homeY: homeY,
          vx: (Math.random() - 0.5) * 0.08, // Faster base velocity
          vy: (Math.random() - 0.5) * 0.08,
          baseVx: (Math.random() - 0.5) * 0.08, // Store base velocity for drift
          baseVy: (Math.random() - 0.5) * 0.08,
          size: Math.random() * 3 + 1,
          opacity: Math.random() * 0.8 + 0.2,
          baseOpacity: Math.random() * 0.8 + 0.2, // Store original opacity (same as opacity)
          hue: baseHue,
          baseHue: baseHue, // Store original hue
          baseSaturation: Math.random() * 40 + 60, // Store original saturation (60-100%)
          baseLightness: Math.random() * 30 + 40, // Store original lightness (40-70%)
          pulse: Math.random() * Math.PI * 2,
          driftPhase: Math.random() * Math.PI * 2, // For smooth drifting motion
          driftSpeed: Math.random() * 0.0005 + 0.0003, // Faster drift speed
          connections: [], // Array of connected particle indices
          currentHue: baseHue, // Start with same hue as baseHue
          waveIntensity: 0, // How much the wave affects this particle (0-1)
          waveDecay: 0, // Decay rate for wave effect
          constellationId: -1 // Will be set during connection establishment
        });
      }
      console.log('[ConstellationSystem] createParticles() finished');
    }

    establishConnections() {
      // No-op: we now connect visually per frame, not by group.
    }
    
    createConstellation(startParticleIndex: number, constellationId: number, connectionDistance: number, minSize: number, maxSize: number, grid: Map<string, number[]>, cellSize: number, connectionDistanceSq: number): number[] {
      console.log('[ConstellationSystem] createConstellation() called');
      const constellation = [startParticleIndex];
      const toCheck = [startParticleIndex];
      const checked = new Set([startParticleIndex]);
      
      while (toCheck.length > 0 && constellation.length < maxSize) {
        const currentIndex = toCheck.shift()!;
        const currentParticle = this.particles[currentIndex];

        // Search neighboring grid cells only
        const cx = Math.floor(currentParticle.x / cellSize);
        const cy = Math.floor(currentParticle.y / cellSize);
        for (let gx = cx - 1; gx <= cx + 1; gx++) {
          for (let gy = cy - 1; gy <= cy + 1; gy++) {
            const bucket = grid.get(`${gx}:${gy}`);
            if (!bucket) continue;
            for (let k = 0; k < bucket.length; k++) {
              const otherIndex = bucket[k];
              if (checked.has(otherIndex) || otherIndex === currentIndex) continue;
              const otherParticle = this.particles[otherIndex];

              const dx = currentParticle.x - otherParticle.x;
              const dy = currentParticle.y - otherParticle.y;
              let distSq = dx * dx + dy * dy;

              // Randomize effective radius a bit (0.8..1.2)
              const scale = 0.8 + Math.random() * 0.4;
              if (distSq < (connectionDistanceSq * scale * scale)) {
                if (constellation.length < maxSize) {
                  constellation.push(otherIndex);
                  toCheck.push(otherIndex);
                  checked.add(otherIndex);
                }
              }
              if (constellation.length >= maxSize) break;
            }
          }
        }
      }
      console.log('[ConstellationSystem] createConstellation() finished');
      return constellation;
    }
    
    createConstellationConnections(constellation: number[], connectionDistance: number, connectionDistanceSq: number, grid: Map<string, number[]>, cellSize: number) {
      console.log('[ConstellationSystem] createConstellationConnections() called');
      // Create connections within the constellation
      const maxConnectionsPerParticle = 8;
      constellation.forEach((particleIndex) => {
        const particle = this.particles[particleIndex];
        const cx = Math.floor(particle.x / cellSize);
        const cy = Math.floor(particle.y / cellSize);
        const candidates: number[] = [];
        for (let gx = cx - 1; gx <= cx + 1; gx++) {
          for (let gy = cy - 1; gy <= cy + 1; gy++) {
            const bucket = grid.get(`${gx}:${gy}`);
            if (bucket) candidates.push(...bucket);
          }
        }
        for (let i = 0; i < candidates.length; i++) {
          const otherIndex = candidates[i];
          if (otherIndex === particleIndex) continue;
          if (particle.connections.length >= maxConnectionsPerParticle) break;
          const otherParticle = this.particles[otherIndex];
          if (otherParticle.constellationId !== particle.constellationId) continue;
          const dx = particle.x - otherParticle.x;
          const dy = particle.y - otherParticle.y;
          const distSq = dx * dx + dy * dy;
          if (distSq < connectionDistanceSq * 1.44 && !particle.connections.includes(otherIndex)) {
            particle.connections.push(otherIndex);
          }
        }
      });
      console.log('[ConstellationSystem] createConstellationConnections() finished');
    }
    
    mergeSmallConstellation(constellation: number[], unassignedParticles: number[], constellationId: number, constellationMembers: Map<number, Set<number>>, maxSize: number) {
      console.log('[ConstellationSystem] mergeSmallConstellation() called');
      // Try to find a nearby existing constellation to merge with
      if (constellation.length === 0) return;
      
      const startParticle = this.particles[constellation[0]];
      let closestConstellation = -1;
      let closestDistance = Infinity;
      
      // Find the closest existing constellation
      this.particles.forEach((particle, index) => {
        if (particle.constellationId !== -1 && particle.constellationId !== constellationId) {
          const distance = Math.sqrt(
            Math.pow(startParticle.x - particle.x, 2) + 
            Math.pow(startParticle.y - particle.y, 2)
          );
          
          if (distance < closestDistance) {
            closestDistance = distance;
            closestConstellation = particle.constellationId;
          }
        }
      });
      
      if (closestConstellation !== -1 && closestDistance < 200) {
        const members = constellationMembers.get(closestConstellation) || new Set<number>();
        if (members.size + constellation.length <= maxSize) {
        // Merge with closest constellation
          constellation.forEach(particleIndex => {
            this.particles[particleIndex].constellationId = closestConstellation;
            members.add(particleIndex);
            const unassignedIndex = unassignedParticles.indexOf(particleIndex);
            if (unassignedIndex > -1) unassignedParticles.splice(unassignedIndex, 1);
          });
          constellationMembers.set(closestConstellation, members);
          return;
        }
      } else {
        // Keep as unassigned for next iteration
        constellation.forEach(particleIndex => {
          if (!unassignedParticles.includes(particleIndex)) {
            unassignedParticles.push(particleIndex);
          }
        });
      }
      console.log('[ConstellationSystem] mergeSmallConstellation() finished');
    }
    
    // Replace the main loop in mergeRemainingParticles with a hard iteration cap
    mergeRemainingParticles(unassignedParticles: number[], connectionDistance: number, connectionDistanceSq: number, constellationMembers: Map<number, Set<number>>, maxSize: number, grid: Map<string, number[]>, cellSize: number, nextId: () => number) {
      // Cap to N seeds to guarantee early bailout
      const safetyMaxSeeds = 2000;
      const assigned = new Set<number>();
      let seedsChecked = 0;
      for (let idx of unassignedParticles) {
        if (assigned.has(idx) || this.particles[idx].constellationId !== -1) continue;
        if (++seedsChecked > safetyMaxSeeds) {
          console.error('[ConstellationSystem] Too many constellation seeds processed; aborting to protect browser.');
          this.showFailMessage('Too many constellations to process, aborting for safety.');
          break;
        }
        const p = this.particles[idx];
        const newId = nextId();
        const members = new Set<number>([idx]);
        p.constellationId = newId;
        assigned.add(idx);
        const cx = Math.floor(p.x / cellSize);
        const cy = Math.floor(p.y / cellSize);
        for (let gx = cx - 1; gx <= cx + 1; gx++) {
          for (let gy = cy - 1; gy <= cy + 1; gy++) {
            const bucket = grid.get(`${gx}:${gy}`);
            if (bucket) for (let nidx of bucket) {
              if (assigned.has(nidx) || nidx === idx) continue;
              const np = this.particles[nidx];
              if (np.constellationId === -1) {
                const dx = p.x - np.x, dy = p.y - np.y;
                if (dx*dx + dy*dy <= connectionDistanceSq) {
                  np.constellationId = newId;
                  members.add(nidx);
                  assigned.add(nidx);
                  if (members.size >= maxSize) break;
                }
              }
            }
          }
          if (members.size >= maxSize) break;
        }
        constellationMembers.set(newId, members);
        this.createConstellationConnections(Array.from(members), connectionDistance, connectionDistanceSq, grid, cellSize);
      }
      console.log('[ConstellationSystem] mergeRemainingParticles() finished');
    }

    bindEvents() {
      console.log('[ConstellationSystem] bindEvents() called');
      window.addEventListener('resize', () => this.resizeCanvas());
      
      this.canvas.addEventListener('mousemove', (e) => {
        const rect = this.canvas.getBoundingClientRect();
        this.mouse.x = e.clientX - rect.left;
        this.mouse.y = e.clientY - rect.top;
      });
      
      this.canvas.addEventListener('mouseleave', () => {
        this.mouse.x = 0;
        this.mouse.y = 0;
      });
      
      // Mark first user interaction and stop auto-clicks
      const markInteracted = (e: Event) => {
        // Only mark as interaction if it's a trusted user event
        if (e.isTrusted && !this.userInteracted) {
          this.userInteracted = true;
          if (this.autoClickIntervalId !== null) {
            clearInterval(this.autoClickIntervalId);
            this.autoClickIntervalId = null;
          }
        }
      };
      document.addEventListener('click', markInteracted, { once: true, capture: true });
      document.addEventListener('keydown', markInteracted, { once: true, capture: true });
      document.addEventListener('touchstart', markInteracted, { once: true, capture: true });

      // Add click interaction for constellation dots - works anywhere on page
      document.addEventListener('click', (e) => {
        // Only mark as user interaction if it's not a simulated click
        if (!e.isTrusted) {
          // This is a simulated click, don't mark as user interaction
        } else {
          // This is a real user click, mark as interaction
          this.userInteracted = true;
        }
        
        // Allow clicks with 0.5 second cooldown
        const now = Date.now();
        if (now - this.lastClickTime < 500) {
          return; // Ignore clicks within 500ms of previous click
        }
        this.lastClickTime = now;
        
        // Check if click is on a button or link - if so, don't interfere
        const target = e.target as HTMLElement;
        if (!target) return;
        
        if (target.tagName === 'A' || target.tagName === 'BUTTON' || 
            (target.classList && target.classList.contains('category-card')) ||
            (target.parentElement && (target.parentElement.tagName === 'A' || target.parentElement.tagName === 'BUTTON'))) {
          return;
        }
        
        const rect = this.canvas.getBoundingClientRect();
        const clickX = e.clientX - rect.left;
        const clickY = e.clientY - rect.top;
        
        // Only process clicks within canvas bounds
        if (clickX >= 0 && clickX <= this.canvas.width && 
            clickY >= 0 && clickY <= this.canvas.height) {
          
          // Find the closest particle to the click
          let closestParticle = null;
          let closestDistance = Infinity;
          
          this.particles.forEach(particle => {
            const distance = Math.sqrt(
              Math.pow(particle.x - clickX, 2) + 
              Math.pow(particle.y - clickY, 2)
            );
            
            if (distance < closestDistance && distance < 80) { // Increased range
              closestDistance = distance;
              closestParticle = particle;
            }
          });
          
          if (closestParticle) {
            this.createConstellationClickEffect(clickX, clickY, closestParticle);
          }
        }
      });
      console.log('[ConstellationSystem] bindEvents() finished');
    }
    
    // Start automatic clicks every 10s until the first user interaction
    startAutoClickRoutine() {
      console.log('[ConstellationSystem] startAutoClickRoutine() called');
      // If already interacted or already running, do nothing
      if (this.userInteracted || this.autoClickIntervalId !== null) {
        console.log('[ConstellationSystem] Auto-click routine skipped: user has interacted or already running.');
        return;
      }
      
      const triggerRandomParticleClick = () => {
        if (this.userInteracted) {
          console.log('[ConstellationSystem] Auto-click stopped: user has interacted');
          return;
        }
        if (!this.particles || this.particles.length === 0) {
          console.log('[ConstellationSystem] Auto-click skipped: no particles available');
          return;
        }
        
        const randomIndex = Math.floor(Math.random() * this.particles.length);
        const particle = this.particles[randomIndex];
        if (!particle) {
          console.log('[ConstellationSystem] Auto-click skipped: no particle at random index');
          return;
        }
        
        const rect = this.canvas.getBoundingClientRect();
        const clientX = particle.x + rect.left;
        const clientY = particle.y + rect.top;
        
        console.log(`[ConstellationSystem] Auto-clicking particle at (${clientX}, ${clientY})`);
        
        // Dispatch a click at the particle's screen position
        const evt = new MouseEvent('click', {
          clientX,
          clientY,
          bubbles: true,
          cancelable: true,
          view: window
        });
        document.dispatchEvent(evt);
      };
      
      // Fire first auto-click 10s after full load, then every 10s
      this.autoClickIntervalId = window.setInterval(triggerRandomParticleClick, 10000);
      console.log('[ConstellationSystem] startAutoClickRoutine() finished');
    }
    
    createConstellationClickEffect(clickX: number, clickY: number, particle: Particle) {
      console.log('[ConstellationSystem] createConstellationClickEffect() called');
      // Create a beautiful color wave effect
      this.createColorWave(clickX, clickY, particle);
      console.log('[ConstellationSystem] createConstellationClickEffect() finished');
    }
    
    createColorWave(clickX: number, clickY: number, startParticle: Particle) {
      console.log('[ConstellationSystem] createColorWave() called');
      // Generate a random beautiful color for this wave
      const waveHue = Math.random() * 360;
      const waveSpeed = 2.0; // Much faster wave travel
      const waveIntensity = 1.0; // Maximum intensity
      const waveDecay = 0.01; // Slower decay - circles last exactly 1 second
      
      // Create the wave object
      const wave: ColorWave = {
        x: clickX,
        y: clickY,
        hue: waveHue,
        intensity: waveIntensity,
        speed: waveSpeed,
        decay: waveDecay,
        radius: 0,
        maxRadius: 300, // Maximum wave radius
        affectedParticles: new Set<Particle>(), // Track which particles this wave has affected
        startTime: Date.now()
      };
      
      this.colorWaves.push(wave);
      
      // Start the wave from the clicked particle
      this.propagateWave(wave, startParticle);
      console.log('[ConstellationSystem] createColorWave() finished');
    }
    
    propagateWave(wave: ColorWave, particle: Particle) {
      console.log('[ConstellationSystem] propagateWave() called');
      // Mark this particle as affected by this wave
      wave.affectedParticles.add(particle);
      
      // Apply wave effect to this particle - only brightness and size, keep original color
      particle.waveIntensity = wave.intensity;
      particle.waveDecay = wave.decay;
      // Don't change currentHue - keep original color
      
      // Propagate to connected particles
      particle.connections.forEach((connectionIndex: number) => {
        const connectedParticle = this.particles[connectionIndex];
        if (connectedParticle && !wave.affectedParticles.has(connectedParticle)) {
          // Add a small delay for wave propagation effect
          setTimeout(() => {
            this.propagateWave(wave, connectedParticle);
          }, Math.random() * 30 + 20); // Much faster propagation: 20-50ms delay
        }
      });
      console.log('[ConstellationSystem] propagateWave() finished');
    }
    
    updateColorWaves() {
      console.log('[ConstellationSystem] updateColorWaves() called');
      // Update all active color waves
      this.colorWaves = this.colorWaves.filter(wave => {
        // Update wave properties
        wave.radius += wave.speed;
        wave.intensity -= wave.decay;
        
        // Remove wave if it's faded out or reached max radius
        if (wave.intensity <= 0 || wave.radius >= wave.maxRadius) {
          // Reset affected particles - but don't instantly change colors
          wave.affectedParticles.forEach((particle: any) => {
            particle.waveIntensity = 0;
            particle.waveDecay = 0;
            // Don't instantly reset currentHue - let it fade naturally
          });
          return false; // Remove this wave
        }
        
        return true; // Keep this wave
      });
      
      // Update particle wave effects
      this.particles.forEach((particle: any) => {
        if (particle.waveIntensity > 0) {
          particle.waveIntensity -= particle.waveDecay;
          if (particle.waveIntensity <= 0) {
            particle.waveIntensity = 0;
            particle.waveDecay = 0;
            // Colors stay the same - no transition needed
          }
        }
      });
      
      // Waves continue to run independently
      console.log('[ConstellationSystem] updateColorWaves() finished');
    }
    
    updateParticles() {
      console.log('[ConstellationSystem] updateParticles() called');
      // Update color waves
      this.updateColorWaves();
      
      // Limit total particles to prevent performance issues
      const maxParticles = 200;
      if (this.particles.length > maxParticles) {
        // Remove oldest mini-particles first
        this.particles = this.particles.filter(p => p.life === undefined).slice(0, maxParticles);
      }
      
      this.particles.forEach((particle, index) => {
        // Handle mini-particles with life spans
        if (particle.life !== undefined) {
          particle.life--;
          particle.opacity = particle.life / 60;
          
          if (particle.life <= 0) {
            this.particles.splice(index, 1);
            return;
          }
          
          // Mini-particles move faster and fade out
          particle.x += particle.vx;
          particle.y += particle.vy;
          particle.vx *= 0.98;
          particle.vy *= 0.98;
          return;
        }
        
        // Add gentle drifting motion
        particle.driftPhase += particle.driftSpeed;
        
        // Create smooth circular drift - faster movement
        const driftX = Math.cos(particle.driftPhase) * 0.0015;
        const driftY = Math.sin(particle.driftPhase) * 0.0015;
        
        // Add some randomness to the drift - faster
        const randomDriftX = (Math.random() - 0.5) * 0.0008;
        const randomDriftY = (Math.random() - 0.5) * 0.0008;
        
        // Update velocity with drift
        particle.vx += driftX + randomDriftX;
        particle.vy += driftY + randomDriftY;
        
        // Gradually return to base velocity - stronger pull back to home
        particle.vx += (particle.baseVx - particle.vx) * 0.01;
        particle.vy += (particle.baseVy - particle.vy) * 0.01;

        // Add home attraction force to prevent drifting too far
        const homeDistance = Math.sqrt(
          Math.pow(particle.x - particle.homeX, 2) + 
          Math.pow(particle.y - particle.homeY, 2)
        );
        
        // If particle is more than 100px from home, add attraction force
        if (homeDistance > 100) {
          const homeForce = (homeDistance - 100) * 0.0001; // Stronger force the further away
          const homeDirX = (particle.homeX - particle.x) / homeDistance;
          const homeDirY = (particle.homeY - particle.y) / homeDistance;
          
          particle.vx += homeDirX * homeForce;
          particle.vy += homeDirY * homeForce;
        }

        // Update position
        particle.x += particle.vx;
        particle.y += particle.vy;

        // Mouse interaction
        const dx = this.mouse.x - particle.x;
        const dy = this.mouse.y - particle.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < 120) {
          const force = (120 - distance) / 120;
          particle.vx += (dx / distance) * force * 0.0002;
          particle.vy += (dy / distance) * force * 0.0002;
        }

        // Apply stronger friction to prevent expansion
        particle.vx *= 0.98;
        particle.vy *= 0.98;

        // Boundary check with gentle bounce - keep particles within viewable area with margin
        const margin = 20;
        if (particle.x < margin || particle.x > this.canvas.width - margin) {
          particle.vx *= -0.8;
          particle.x = Math.max(margin, Math.min(this.canvas.width - margin, particle.x));
        }
        if (particle.y < margin || particle.y > this.canvas.height - margin) {
          particle.vy *= -0.8;
          particle.y = Math.max(margin, Math.min(this.canvas.height - margin, particle.y));
        }

        // Update pulse
        particle.pulse += 0.03;
        
        // Note: Brightness is now managed by timeouts, not decay
      });
      console.log('[ConstellationSystem] updateParticles() finished');
    }

    drawParticles() {
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      const N = this.particles.length;
      // Draw connecting lines for all close pairs
      const connectionDistance = 100;
      for (let i = 0; i < N; i++) {
        for (let j = i + 1; j < N; j++) {
          const p1 = this.particles[i], p2 = this.particles[j];
          const dx = p1.x - p2.x, dy = p1.y - p2.y;
          const d2 = dx * dx + dy * dy;
          if (d2 < connectionDistance * connectionDistance) {
            this.ctx.save();
            this.ctx.strokeStyle = 'rgba(255,255,255,0.15)';
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();
            this.ctx.moveTo(p1.x, p1.y);
            this.ctx.lineTo(p2.x, p2.y);
            this.ctx.stroke();
            this.ctx.restore();
          }
        }
      }
      // Draw lines from mouse to close particles
      if (this.mouse.x && this.mouse.y) {
        for (let i = 0; i < N; i++) {
          const p = this.particles[i];
          const dx = this.mouse.x - p.x, dy = this.mouse.y - p.y;
          const d2 = dx * dx + dy * dy;
          if (d2 < connectionDistance * connectionDistance) {
            this.ctx.save();
            this.ctx.strokeStyle = 'rgba(100,200,255,0.15)';
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();
            this.ctx.moveTo(p.x, p.y);
            this.ctx.lineTo(this.mouse.x, this.mouse.y);
            this.ctx.stroke();
            this.ctx.restore();
          }
        }
      }
      // Particles
      for (let i = 0; i < N; i++) {
        const p = this.particles[i];
        this.ctx.save();
        this.ctx.beginPath();
        this.ctx.arc(p.x, p.y, p.size || 2, 0, Math.PI * 2);
        this.ctx.fillStyle = `hsl(${p.baseHue || 0},70%,70%)`;
        this.ctx.globalAlpha = 0.7;
        this.ctx.fill();
        this.ctx.restore();
      }
    }

    animate() {
      console.log('[ConstellationSystem] animate() called');
      try {
        this.updateParticles();
        this.drawParticles();
      } catch (error) {
        console.warn('ConstellationSystem animation error (continuing):', error);
      }
      requestAnimationFrame(() => this.animate());
      console.log('[ConstellationSystem] animate() finished');
    }

    // Cleanup method for proper memory management
    destroy() {
      console.log('[ConstellationSystem] destroy() called');
      this.isRunning = false;
      if (this.autoClickIntervalId !== null) {
        clearInterval(this.autoClickIntervalId);
        this.autoClickIntervalId = null;
      }
      this.particles = [];
      this.colorWaves = [];
      console.log('[ConstellationSystem] destroy() finished');
    }

    // Add a DOM message in .showFailMessage
    showFailMessage(msg: string) {
      try {
        let failDiv = document.getElementById('constellationFailMsg');
        if (!failDiv) {
          failDiv = document.createElement('div');
          failDiv.id = 'constellationFailMsg';
          failDiv.style.position = 'fixed';
          failDiv.style.top = '20px';
          failDiv.style.left = '50%';
          failDiv.style.transform = 'translateX(-50%)';
          failDiv.style.background = 'rgba(0,0,0,0.95)';
          failDiv.style.color = '#fff';
          failDiv.style.border = '2px solid red';
          failDiv.style.fontSize = '18px';
          failDiv.style.padding = '16px 36px';
          failDiv.style.borderRadius = '12px';
          failDiv.style.zIndex = '100000';
          document.body.appendChild(failDiv);
        }
        failDiv.innerText = '[Constellation Error] ' + msg;
      } catch {}
    }
  }

  // Initialize constellation system when DOM is loaded
  document.addEventListener('DOMContentLoaded', function() {
    console.log('DOMContentLoaded fired.');
    try {
      if ((window as any).constellationSystem) {
        console.warn('[ConstellationSystem] Already initialized. Skipping.');
        return;
      }
      console.log('DOM loaded, initializing constellation system...');

      // Initialize constellation particle system
      const constellationSystem = new ConstellationSystem();
      (window as any).constellationSystem = constellationSystem;

      // Start auto-clicks once the page fully loads
      const startAuto = () => constellationSystem.startAutoClickRoutine && constellationSystem.startAutoClickRoutine();
      if (document.readyState === 'complete') {
        startAuto();
      } else {
        window.addEventListener('load', startAuto, { once: true });
      }
    } catch (e) {
      console.error('[ConstellationSystem] Error during DOMContentLoaded:', e);
    }
  });
</script>

<style>
  #particleCanvas {
    z-index: 1 !important;
    pointer-events: none !important;
  }
</style>
